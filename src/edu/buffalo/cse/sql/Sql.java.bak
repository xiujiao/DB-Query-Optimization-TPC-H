/* Generated By:avaCC: Do not edit this line. Sql.java */
package edu.buffalo.cse.sql;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.List;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.math.BigDecimal;

import edu.buffalo.cse.sql.Schema;
import edu.buffalo.cse.sql.Program;
import edu.buffalo.cse.sql.Index.IndexType;
import edu.buffalo.cse.sql.Schema.Var;
import edu.buffalo.cse.sql.buffer.BufferManager;
import edu.buffalo.cse.sql.buffer.FileManager;
import edu.buffalo.cse.sql.buffer.ManagedFile;
import edu.buffalo.cse.sql.data.Datum;
import edu.buffalo.cse.sql.SqlParser;
import edu.buffalo.cse.sql.plan.*;
import edu.buffalo.cse.sql.test.TestDataStream;
import edu.buffalo.cse.sql.util.TableBuilder;
import edu.buffalo.cse.sql.index.GenericIndexKeySpec;
import edu.buffalo.cse.sql.index.ISAMIndex;
import edu.buffalo.cse.sql.index.IndexFile;
import edu.buffalo.cse.sql.index.IndexKeySpec;
import edu.buffalo.cse.sql.io.Readtable;
import edu.buffalo.cse.sql.io.Readtable_old;

import java.util.regex.*;
import edu.buffalo.cse.sql.optimizer.*;

public class Sql {

	public static void main(String[] args) throws SqlException, IOException {
		
		File f = new File("error.log");
		try {
			PrintStream errorPrinter = new PrintStream(new BufferedOutputStream(new FileOutputStream(f)));
			System.setErr(errorPrinter);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}
		System.out.println("I am here!!!");
		/////////////////////////////////////////////////////
		if (args.length == 0) {
			System.out
					.println("You did not put the path of the SQl file you want to test!");
		}

		if (args[0].equals("-explain")) {
			File programFile = new File(args[1]);
			execFile(programFile, "-explain");
		} else if (args[0].equals("-index")) {
			File programFile = new File(args[1]);
			execFile(programFile, "-index");
		} else {
			File programFile = new File(args[0]);
			execFile(programFile, null);
		}
		
		// System.out.println("You haven't implemented me yet!");
	}

	public static List<Datum[]> execQuery(
			Map<String, Schema.TableFromFile> tables, PlanNode q, int mark)
			throws SqlException {
		
		String qq = q.detailString();
		
		IndexType type = IndexType.ISAM;
		int keys = 1;// the size of the key
		int values = 5;// the size of the value so
						// keys+values size is the size
						// of one row
		int rows = 100;
		int frames = 1024;// the size of neicun
		int keychaos = 2;// the randomness of the key
		int indexSize = 10;// for hash
		
		BufferManager bm = new BufferManager(frames);
		FileManager fm = new FileManager(bm);

		if (qq.contains("PROJECT") && mark == 1) {
			ArrayList<PlanNode> pl = new ArrayList<PlanNode>(); // the arraylist
																// records the
																// nodes of the
																// tree [1]
			ArrayList indexpl = new ArrayList(); // the arraylist records the
													// structure of the tree [2]
			int root = 1;
			int i = 0;
			int j = 0;
			int j0 = 1;
			int in = 0;// index in the tree
			pl.add(q);
			indexpl.add(root);// recording the tree relationship
			PlanNode q1;
			PlanNode q3;
			PlanNode ql;
			PlanNode qr;

			while (j0 > j)// no new nodes are found
			{
				for (int k = j + 1; k <= j0; k++) {
					q1 = pl.get(k - 1);
					in = (Integer) indexpl.get(k - 1);
					int m = 1;
					switch (q1.type) {
					case AGGREGATE:
						j = pl.size();
						AggregateNode q2 = (AggregateNode) q1;
						q3 = q2.getChild();
						pl.add(q3);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case PROJECT:
						j = pl.size();
						ProjectionNode q21 = (ProjectionNode) q1;
						q3 = q21.getChild();
						pl.add(q3);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case SELECT:
						j = pl.size();
						SelectionNode q22 = (SelectionNode) q1;
						q3 = q22.getChild();
						pl.add(q3);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case JOIN:
						j = pl.size();
						JoinNode q23 = (JoinNode) q1;
						ql = q23.getLHS();
						qr = q23.getRHS();
						pl.add(ql);
						indexpl.add(in * 10 + m);
						m = m + 1;
						pl.add(qr);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case UNION:
						j = pl.size();
						UnionNode q25 = (UnionNode) q1;
						ql = q25.getLHS();
						qr = q25.getRHS();
						pl.add(ql);
						indexpl.add(in * 10 + m);
						m = m + 1;
						pl.add(qr);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case NULLSOURCE:
						j = pl.size();
						indexpl.add(in * 10 + m);
						m = m + 1;
						// i=1;
						break;
					case SCAN:
						j = pl.size();
						indexpl.add(in * 10 + m);
						m = m + 1;
						// i=1;
						break;
					}
				}
				j0 = pl.size();
			}
			int s = pl.size();
			int jointimes = 0;
			int indi[] = new int[s];// if the child node has provided some
									// useful information
			ArrayList data = new ArrayList();// the third arraylist, which
												// records the data associated
												// with node [3]
			ArrayList COLNAMES = new ArrayList();// record the column names of
													// the arraylist "data"
			ArrayList RANGENAMES = new ArrayList();// record the range names of
													// the arraylist "data"
			for (int k1 = 0; k1 < s; k1++) {
				ArrayList<String[]> data1 = new ArrayList();
				data.add(data1);
				COLNAMES.add(data1);
				RANGENAMES.add(data1);
			}
			ArrayList table = new ArrayList();
			for (int k5 = s; k5 >= 1; k5--) {
				// if (indi[k]==0){
				in = (Integer) indexpl.get(k5 - 1);
				// if (indexpl.contains(in-1))// this is one of the binary child
				// nodes
				// {}
				// else //this is a unary child node or its father node is unary
				// {
				q1 = pl.get(k5 - 1);

				switch (q1.type) {
				case SCAN:
					String q1s = q1.detailString();
					int a = q1s.indexOf("[");
					int b = q1s.indexOf("(");
					int c1 = q1s.indexOf(")");
					String rangeVar = q1s.substring(a + 1, b);
					String col1 = q1s.substring(b + 1, b + 2);
					String col2 = q1s.substring(c1 - 1, c1);
					q1s = q1s.trim();
					table.add(in);
					table.add(rangeVar);
					table.add(col1);
					table.add(col2);
					int i341 = indexpl.indexOf(in);// this child node can
													// provide data to its
													// father node
					indi[i341] = 1;
					break;
				case AGGREGATE:
					String q2s = q1.detailString();

					int i1 = 0;
					int i2 = 0;
					int index1 = -100;
					int cal = 0; // calculation number in AGGREGATE
					String arraytotal[][] = new String[0][0];
					String[] colnames2 = new String[0];
					ArrayList<Datum[]> ret = new ArrayList<Datum[]>();
					ArrayList<Datum> ret12 = new ArrayList<Datum>();
					if (q2s.contains("SUM")) {
						int a1 = q2s.indexOf("M");
						int b1 = q2s.indexOf(")");
						i1 = 0;
						i2 = 0;
						index1 = -100;
						String parString = q2s.substring(a1 + 1, b1);
						if (parString.contains("+")) {
							int id1 = 0;
							int id2 = 0;
							int a111 = parString.indexOf("+");
							String leftCol = parString.substring(a111 - 2,
									a111 - 1);
							String righCol = parString.substring(a111 + 2,
									a111 + 3);

							int i6 = indexpl.indexOf(in * 10 + 1);
							arraytotal = (String[][]) data.get(i6);
							colnames2 = (String[]) COLNAMES.get(i6);
							for (int i123 = 0; i123 < colnames2.length; i123++) {
								if (colnames2[i123].equals(leftCol)) {
									id1 = i123;
								}
								if (colnames2[i123].equals(righCol)) {
									id2 = i123;
								}
							}
							int sum = 0;
							for (i = 0; i < arraytotal.length; i++) {
								sum = sum
										+ Integer.parseInt(arraytotal[i][id1])
										+ Integer.parseInt(arraytotal[i][id2]);// convert
																				// string
																				// to
																				// int
							}
							if (sum != 0) {
								ret12.add(new Datum.Int(sum));
								cal++;
							}

						} else if (q2s.contains("*")) {
							int id1 = 0;
							int id2 = 0;
							int a111 = parString.indexOf("*");
							String leftCol = parString.substring(a111 - 2,
									a111 - 1);
							String righCol = parString.substring(a111 + 2,
									a111 + 3);

							int i6 = indexpl.indexOf(in * 10 + 1);
							arraytotal = (String[][]) data.get(i6);
							colnames2 = (String[]) COLNAMES.get(i6);
							for (int i123 = 0; i123 < colnames2.length; i123++) {
								if (colnames2[i123].equals(leftCol)) {
									id1 = i123;
								}
								if (colnames2[i123].equals(righCol)) {
									id2 = i123;
								}
							}
							int sum = 0;
							for (i = 0; i < arraytotal.length; i++) {
								sum = sum
										+ Integer.parseInt(arraytotal[i][id1])
										* Integer.parseInt(arraytotal[i][id2]);// convert
																				// string
																				// to
																				// int
							}
							if (sum != 0) {
								ret12.add(new Datum.Int(sum));
								cal++;
							}
						} else {
							String colName = q2s.substring(a1 + 2, a1 + 3);

							if (table.contains(in * 10 + 1))// from the file
							{
								i1 = table.indexOf(colName);
								i2 = table.indexOf(in * 10 + 1);

								Schema.TableFromFile table_R = tables.get(table
										.get(i2 + 1));
								String pathadd = table_R.getFile().toString();
								Readtable_old readr = new Readtable_old();
								arraytotal = readr.readfile(pathadd);
							} else // not from the file, but from the results of
									// its child node
							{
								int i6 = indexpl.indexOf(in * 10 + 1);
								arraytotal = (String[][]) data.get(i6);
								// System.out.println((String
								// [])COLNAMES.get(i6));
								String[] colnames3 = (String[]) COLNAMES
										.get(i6);
								for (int i123 = 0; i123 < colnames3.length; i123++) {
									if (colnames3[i123].equals(colName)) {
										index1 = i123;
									}
								}

							}
							int sum = 0;
							if (i1 == i2 + 2) {
								for (i = 0; i < arraytotal.length; i++) {
									sum = sum
											+ Integer
													.parseInt(arraytotal[i][0]);// convert
																				// string
																				// to
																				// int
								}
							} else if (i1 == i2 + 3) {
								for (i = 0; i < arraytotal.length; i++) {
									sum = sum
											+ Integer
													.parseInt(arraytotal[i][1]);// convert
																				// string
																				// to
																				// int
								}
							} else if (index1 != -100) {
								for (i = 0; i < arraytotal.length; i++) {
									sum = sum
											+ Integer
													.parseInt(arraytotal[i][index1]);// convert
																						// string
																						// to
																						// int
								}
							}

							// Schema.Var v1=new Schema.Var ("R",colName);

							// System.out.println(table_R.lookup(v1));
							// ArrayList<Datum[]> ret = new
							// ArrayList<Datum[]>();
							if (sum != 0) {
								ret12.add(new Datum.Int(sum));
								cal++;
							}
						}
						// ret.add(new Datum[] {new Datum.Int(sum)});
						// return ret;
					}
					if (q2s.contains("AVG")) {
						int a1 = q2s.indexOf("G(");
						int b1 = 0;
						for (int i41 = a1 + 1; i41 < q2s.length(); i41++) {
							if (q2s.substring(i41, i41 + 1).equals(")")) {
								b1 = i41;
								break;
							}
						}
						i1 = 0;
						i2 = 0;
						index1 = -100;
						String parString = q2s.substring(a1 + 1, b1);
						if (parString.contains("+")) {
							int id1 = 0;
							int id2 = 0;
							int a111 = parString.indexOf("+");
							String leftCol = parString.substring(a111 - 2,
									a111 - 1);
							String righCol = parString.substring(a111 + 2,
									a111 + 3);

							int i6 = indexpl.indexOf(in * 10 + 1);
							arraytotal = (String[][]) data.get(i6);
							colnames2 = (String[]) COLNAMES.get(i6);
							for (int i123 = 0; i123 < colnames2.length; i123++) {
								if (colnames2[i123].equals(leftCol)) {
									id1 = i123;
								}
								if (colnames2[i123].equals(righCol)) {
									id2 = i123;
								}
							}
							int sum = 0;
							for (i = 0; i < arraytotal.length; i++) {
								sum = sum
										+ Integer.parseInt(arraytotal[i][id1])
										+ Integer.parseInt(arraytotal[i][id2]);// convert
																				// string
																				// to
																				// int
							}
							float average = 0;
							float count = arraytotal.length;
							float sum2 = sum;
							average = sum2 / count;
							// ArrayList<Datum[]> ret = new
							// ArrayList<Datum[]>();
							if (sum != 0) {
								ret12.add(new Datum.Flt(average));
								cal++;
							}

						} else if (q2s.contains("*")) {

						} else {
							// String arraytotal[][]=new String [0][0];
							// String [] colnames2=new String [0];
							String colName = q2s.substring(a1 + 2, a1 + 3);
							// ArrayList<Datum[]> ret = new
							// ArrayList<Datum[]>();
							if (table.contains(in * 10 + 1))// from the file
							{
								i1 = table.indexOf(colName);
								i2 = table.indexOf(in * 10 + 1);

								Schema.TableFromFile table_R = tables.get(table
										.get(i2 + 1));
								String pathadd = table_R.getFile().toString();
								Readtable_old readr = new Readtable_old();
								arraytotal = readr.readfile(pathadd);
							} else // not from the file, but from the results of
							{
								int i6 = indexpl.indexOf(in * 10 + 1);
								arraytotal = (String[][]) data.get(i6);
								colnames2 = (String[]) COLNAMES.get(i6);
								for (int i123 = 0; i123 < colnames2.length; i123++) {
									if (colnames2[i123].equals(colName)) {
										index1 = i123;
									}
								}

							}
							int sum = 0;
							if (i1 == i2 + 2) {
								for (i = 0; i < arraytotal.length; i++) {
									sum = sum
											+ Integer
													.parseInt(arraytotal[i][0]);// convert
																				// string
																				// to
																				// int
								}
							} else if (i1 == i2 + 3) {
								for (i = 0; i < arraytotal.length; i++) {
									sum = sum
											+ Integer
													.parseInt(arraytotal[i][1]);// convert
																				// string
																				// to
																				// int
								}
							} else if (index1 != -100) {
								for (i = 0; i < arraytotal.length; i++) {
									sum = sum
											+ Integer
													.parseInt(arraytotal[i][index1]);// convert
																						// string
																						// to
																						// int
								}
							}
							float average = 0;
							float count = arraytotal.length;
							float sum2 = sum;
							average = sum2 / count;
							// ArrayList<Datum[]> ret = new
							// ArrayList<Datum[]>();
							if (sum != 0) {
								ret12.add(new Datum.Flt(average));
								cal++;
							}
						}
						// ret.add(new Datum[] {new Datum.Flt(average)});
						// return ret;
					}
					if (q2s.contains("MIN")) {
						int a1 = q2s.indexOf("N");
						int b1 = q2s.indexOf(")");
						i1 = 0;
						i2 = 0;
						index1 = -100;
						// Starraytotal[][]=new String [0][0];
						// String [] colnames2=new String [0];
						String colName = q2s.substring(a1 + 2, a1 + 3);
						// ArrayList<Datum[]> ret = new ArrayList<Datum[]>();
						if (table.contains(in * 10 + 1))// from the file
						{
							i1 = table.indexOf(colName);
							i2 = table.indexOf(in * 10 + 1);

							Schema.TableFromFile table_R = tables.get(table
									.get(i2 + 1));
							String pathadd = table_R.getFile().toString();
							Readtable_old readr = new Readtable_old();
							arraytotal = readr.readfile(pathadd);
						} else // not from the file, but from the results of its
								// child node
						{
							int i6 = indexpl.indexOf(in * 10 + 1);
							arraytotal = (String[][]) data.get(i6);
							colnames2 = (String[]) COLNAMES.get(i6);
							for (int i123 = 0; i123 < colnames2.length; i123++) {
								if (colnames2[i123].equals(colName)) {
									index1 = i123;
								}
							}

						}
						int min = 1000000;
						if (i1 == i2 + 2) {
							for (i = 0; i < arraytotal.length; i++) {
								if (Integer.parseInt(arraytotal[i][0]) < min) {
									min = Integer.parseInt(arraytotal[i][0]);
								}
								;// convert string to int
							}
						} else if (i1 == i2 + 3) {
							for (i = 0; i < arraytotal.length; i++) {
								if (Integer.parseInt(arraytotal[i][1]) < min) {
									min = Integer.parseInt(arraytotal[i][1]);
								}// convert string to int
							}
						}

						// ArrayList<Datum[]> ret = new ArrayList<Datum[]>();
						if (min != 1000000) {
							ret12.add(new Datum.Int(min));
							cal++;
						}
						// ret.add(new Datum[] {new Datum.Int(min)});
						// return ret;
					}
					if (q2s.contains("MAX")) {
						int a1 = q2s.indexOf("X");
						int b1 = q2s.indexOf(")");
						i1 = 0;
						i2 = 0;
						index1 = -100;
						// String arraytotal[][]=new String [0][0];
						// String [] colnames2=new String [0];
						String colName = q2s.substring(a1 + 2, a1 + 3);
						// ArrayList<Datum[]> ret = new ArrayList<Datum[]>();
						if (table.contains(in * 10 + 1))// from the file
						{
							i1 = table.indexOf(colName);
							i2 = table.indexOf(in * 10 + 1);

							Schema.TableFromFile table_R = tables.get(table
									.get(i2 + 1));
							String pathadd = table_R.getFile().toString();
							Readtable_old readr = new Readtable_old();
							arraytotal = readr.readfile(pathadd);
						} else // not from the file, but from the results of its
								// child node
						{
							int i6 = indexpl.indexOf(in * 10 + 1);
							arraytotal = (String[][]) data.get(i6);
							colnames2 = (String[]) COLNAMES.get(i6);
							for (int i123 = 0; i123 < colnames2.length; i123++) {
								if (colnames2[i123].equals(colName)) {
									index1 = i123;
								}
							}

						}
						int max = -1000000;
						if (i1 == i2 + 2) {
							for (i = 0; i < arraytotal.length; i++) {
								if (Integer.parseInt(arraytotal[i][0]) > max) {
									max = Integer.parseInt(arraytotal[i][0]);
								}
								;// convert string to int
							}
						} else if (i1 == i2 + 3) {
							for (i = 0; i < arraytotal.length; i++) {
								if (Integer.parseInt(arraytotal[i][1]) > max) {
									max = Integer.parseInt(arraytotal[i][1]);
								}// convert string to int
							}
						}

						// ArrayList<Datum[]> ret = new ArrayList<Datum[]>();
						if (max != -1000000) {
							ret12.add(new Datum.Int(max));
							cal++;
						}
						// ret.add(new Datum[] {new Datum.Int(max)});
						// return ret;
					}
					if (q2s.contains("COUNT")) {
						int a1 = q2s.indexOf("T");
						int b1 = q2s.indexOf(")");

						String colName = q2s.substring(a1 + 2, a1 + 3);
						// ArrayList<Datum[]> ret = new ArrayList<Datum[]>();
						if (table.contains(in * 10 + 1))// from the file
						{
							i1 = table.indexOf(colName);
							i2 = table.indexOf(in * 10 + 1);

							Schema.TableFromFile table_R = tables.get(table
									.get(i2 + 1));
							String pathadd = table_R.getFile().toString();
							Readtable_old readr = new Readtable_old();
							arraytotal = readr.readfile(pathadd);
						} else // not from the file, but from the results of its
								// child node
						{
							int i6 = indexpl.indexOf(in * 10 + 1);
							arraytotal = (String[][]) data.get(i6);
							// colnames2=(String [])COLNAMES.get(i6);
							// for (int i123=0;i123<colnames2.length;i123++){
							// if (colnames2[i123].equals(colName)){
							// index1=i123;
							// }
							// }

						}
						int count = 0;
						count = arraytotal.length;

						if (count != 0) {
							ret12.add(new Datum.Int(count));
							cal++;
						}
						// ret.add(new Datum[] {new Datum.Int(count)});

					}
					Datum[] ret13 = new Datum[cal];// now the datum [] lenth is
													// the number of
													// calculations
					for (int i13 = 0; i13 < cal; i13++) {
						ret13[i13] = ret12.get(i13);
					}
					ret.add(ret13);
					return ret;
					// break;
				case PROJECT:

					String q3s = q1.detailString();
					if (q3s.contains(":") && !q3s.contains("EXPR")
							&& !q3s.contains("bob") && !q3s.contains("joe")) {
						q3s = q3s.trim();
						ArrayList nPro = new ArrayList();// the names after the
															// :
						for (int iPro = 0; iPro < q3s.length(); iPro++) {
							if (q3s.substring(iPro, iPro + 1).equals(":")) {
								nPro.add(q3s.substring(iPro + 2, iPro + 3));
							}
						}

						int i3 = indexpl.indexOf(in * 10 + 1);
						if (indi[i3] == 0) {// no data from child node
							String[][] a1 = new String[1][nPro.size()];
							for (int iPro = 0; iPro < nPro.size(); iPro++) {
								a1[0][iPro] = nPro.get(iPro).toString();
							}
							int i34 = indexpl.indexOf(in);
							indi[i34] = 1;
							data.set(i34, a1);
						} else if (table.contains(in * 10 + 1))// from the file
						{
							int iPro1 = table.indexOf(in * 10 + 1);

							Schema.TableFromFile table_R = tables.get(table
									.get(iPro1 + 1));
							String pathadd = table_R.getFile().toString();
							Readtable_old readr = new Readtable_old();
							arraytotal = readr.readfile(pathadd); // read the
																	// file

							int[] orderCol = new int[nPro.size()];
							for (int iPro2 = 0; iPro2 < 2; iPro2++) {
								for (int iPro = 0; iPro < nPro.size(); iPro++) {
									if (table.get(iPro1 + 2 + iPro2).equals(
											nPro.get(iPro))) {
										orderCol[iPro] = iPro2;
									}
								}
							}
							String[][] a1 = new String[arraytotal.length][orderCol.length];
							for (int iPro = 0; iPro < arraytotal.length; iPro++) {
								for (int iProo = 0; iProo < orderCol.length; iProo++) {
									a1[iPro][iProo] = arraytotal[iPro][orderCol[iProo]];
								}
							}
							int i34 = indexpl.indexOf(in);
							indi[i34] = 1;
							data.set(i34, a1);
							if (in == 1) {
								ArrayList<Datum[]> ret3 = new ArrayList<Datum[]>();
								for (int i7 = 0; i7 < a1.length; i7++) {
									Datum[] ret113 = new Datum[a1[0].length];// now
																				// the
																				// datum
																				// []
																				// lenth
																				// is
																				// the
																				// number
																				// of
																				// calculations
									for (int i13 = 0; i13 < a1[0].length; i13++) {
										ret113[i13] = new Datum.Int(
												Integer.parseInt(a1[i7][i13]));
									}
									ret3.add(ret113);// each row is a datum []
														// type
									// ret3.add(new Datum[] {new
									// Datum.Int(Integer.parseInt(arrayunion[i7][0]))});
								}
								return ret3;
							}
						} else { // from the childnode
							char[] c33 = q3s.toCharArray();
							// ArrayList a1=new ArrayList () ;
							ArrayList colNames123 = new ArrayList();
							ArrayList ragNames123 = new ArrayList();
							for (int i33 = 0; i33 < c33.length; i33++) {
								if (c33[i33] == '.') {
									colNames123.add(String.valueOf(c33[i33 + 1]));
									ragNames123.add(String.valueOf(c33[i33 - 1]));
								}
							}

							int i6 = indexpl.indexOf(in * 10 + 1);
							arraytotal = (String[][]) data.get(i6); // get the
																	// data and
																	// colname
																	// from the
																	// childnode
							colnames2 = (String[]) COLNAMES.get(i6);
							String[] ragNames321 = (String[]) RANGENAMES
									.get(i6);
							// if (ragNames123.size()<colnames2.length)
							// //duplicate
							// {
							// for (int i00=0; i00<ragNames123.size();i00++){
							// ragNames321.add(ragNames123.get(i00));
							// ragNames321.add(ragNames123.get(i00));
							// }
							// }
							// else if (ragNames123.size()==colnames2.length){
							// ragNames321=ragNames123;
							// }

							int[] orderCol = new int[colNames123.size()];
							for (int ior = 0; ior < orderCol.length; ior++) {
								for (int i123 = 0; i123 < colnames2.length; i123++) {
									if (colnames2[i123].equals(colNames123
											.get(ior))
											&& ragNames321[i123]
													.equals(ragNames123
															.get(ior))) {
										orderCol[ior] = i123;

									}
								}
							}

							String[][] a1 = new String[arraytotal.length][orderCol.length];
							for (int iPro = 0; iPro < arraytotal.length; iPro++) {
								for (int iProo = 0; iProo < orderCol.length; iProo++) {
									a1[iPro][iProo] = arraytotal[iPro][orderCol[iProo]];
								}
							}
							int i34 = indexpl.indexOf(in);
							indi[i34] = 1;
							data.set(i34, a1);
							if (in == 1) {
								ArrayList<Datum[]> ret3 = new ArrayList<Datum[]>();
								for (int i7 = 0; i7 < a1.length; i7++) {
									Datum[] ret113 = new Datum[a1[0].length];// now
																				// the
																				// datum
																				// []
																				// lenth
																				// is
																				// the
																				// number
																				// of
																				// calculations
									for (int i13 = 0; i13 < a1[0].length; i13++) {
										ret113[i13] = new Datum.Int(
												Integer.parseInt(a1[i7][i13]));
									}
									ret3.add(ret113);// each row is a datum []
														// type
									// ret3.add(new Datum[] {new
									// Datum.Int(Integer.parseInt(arrayunion[i7][0]))});
								}
								return ret3;
							}
						}

					} else {
						ArrayList<Datum[]> ret1 = new ArrayList<Datum[]>();
						int i3 = indexpl.indexOf(in * 10 + 1);
						if (indi[i3] == 0) {
							if ((q3s.contains("+") || q3s.contains("-")
									|| q3s.contains("*") || q3s.contains("/"))
									&& q3s.contains("(") && q3s.contains(")")) {
								float result = 0;

								if (q3s.contains("+") || q3s.contains("-")) {
									if (q3s.contains("+")) {
										if (q3s.contains("*")) {
											int a11 = q3s.indexOf("((");
											int a22 = q3s.indexOf("+");
											int a33 = q3s.indexOf(")");// /why
																		// )* is
																		// wrong
											int a44 = q3s.indexOf(")]");
											String colName1 = q3s.substring(
													a11 + 2, a22);
											String colName2 = q3s.substring(
													a22 + 1, a33);
											String colName3 = q3s.substring(
													a33 + 3, a44);
											float f1 = Float
													.parseFloat(colName1);
											float f2 = Float
													.parseFloat(colName2);
											float f3 = Float
													.parseFloat(colName3);
											result = (f1 + f2) * f3;
										} else if (q3s.contains("/")) {
											int a11 = q3s.indexOf("((");
											int a22 = q3s.indexOf("+");
											int a33 = q3s.indexOf("/");// /why
																		// )* is
																		// wrong
											int a44 = q3s.indexOf(")]");
											String colName1 = q3s.substring(
													a11 + 2, a22);
											String colName2 = q3s.substring(
													a22 + 1, a33);
											String colName3 = q3s.substring(
													a33 + 2, a44);
											float f1 = Float
													.parseFloat(colName1);
											float f2 = Float
													.parseFloat(colName2);
											float f3 = Float
													.parseFloat(colName3);
											result = (f1 + f2) / f3;

										} else// /only have +
										{
											int aa = q3s.indexOf("(");
											int bb = q3s.indexOf("+");
											int cc = q3s.indexOf(")");
											if (bb > aa && bb < cc)// + is
																	// between (
																	// and )
											{
												String colName1 = q3s.substring(aa + 1, bb);
												String colName2 = q3s.substring(bb + 1, cc);
												float f1 = Float.parseFloat(colName1);
												float f2 = Float.parseFloat(colName2);
												result = f1 + f2;
											}

										}

									} else if (q3s.contains("-")) {
										if (q3s.contains("*")) {
											int a11 = q3s.indexOf("((");
											int a22 = q3s.indexOf("-");
											int a33 = q3s.indexOf("*");// /why
																		// )* is
																		// wrong
											int a44 = q3s.indexOf(")]");
											String colName1 = q3s.substring(
													a11 + 2, a22);
											String colName2 = q3s.substring(
													a22 + 1, a33);
											String colName3 = q3s.substring(
													a33 + 2, a44);
											float f1 = Float
													.parseFloat(colName1);
											float f2 = Float
													.parseFloat(colName2);
											float f3 = Float
													.parseFloat(colName3);
											result = (f1 - f2) * f3;
										} else if (q3s.contains("/")) {
											int a11 = q3s.indexOf("((");
											int a22 = q3s.indexOf("-");
											int a33 = q3s.indexOf("/");// /why
																		// )* is
																		// wrong
											int a44 = q3s.indexOf(")]");
											String colName1 = q3s.substring(
													a11 + 2, a22);
											String colName2 = q3s.substring(
													a22 + 1, a33);
											String colName3 = q3s.substring(
													a33 + 2, a44);
											float f1 = Float
													.parseFloat(colName1);
											float f2 = Float
													.parseFloat(colName2);
											float f3 = Float
													.parseFloat(colName3);
											result = (f1 - f2) / f3;

										} else// /only have -
										{
											int aa = q3s.indexOf("(");
											int bb = q3s.indexOf("-");
											int cc = q3s.indexOf(")");
											if (bb > aa && bb < cc)// + is
																	// between (
																	// and )
											{
												String colName1 = q3s
														.substring(aa + 1, bb);
												String colName2 = q3s
														.substring(bb + 1, cc);
												float f1 = Float
														.parseFloat(colName1);
												float f2 = Float
														.parseFloat(colName2);
												result = f1 - f2;
											}

										}

									}

								} else {
									if (q3s.contains("*"))// do not consider
															// additional + or -
									{
										int a11 = q3s.indexOf("(");
										int a22 = q3s.indexOf("*");
										String colName1 = q3s.substring(
												a11 + 1, a22);
										int a33 = q3s.indexOf(")");
										String colName2 = q3s.substring(
												a22 + 1, a33);
										float f1 = Float.parseFloat(colName1);
										float f2 = Float.parseFloat(colName2);
										result = f1 * f2;

									} else if (q3s.contains("/"))// do not
																	// consider
																	// additional
																	// + or -
									{
										int a11 = q3s.indexOf("(");
										int a22 = q3s.indexOf("/");
										String colName1 = q3s.substring(
												a11 + 1, a22);
										int a33 = q3s.indexOf(")");
										String colName2 = q3s.substring(
												a22 + 1, a33);
										float f1 = Float.parseFloat(colName1);
										float f2 = Float.parseFloat(colName2);
										result = f1 * f2;

									}
								}

								// ///the return value type
								if (q3s.contains("."))// float
								{
									float resultflt;
									resultflt = result;

									ret1.add(new Datum[] { new Datum.Flt(
											resultflt) });
									return ret1;
								} else// /integer
								{
									int resultint;
									resultint = (int) result;
									// ArrayList<Datum[]> ret = new
									// ArrayList<Datum[]>();
									ret1.add(new Datum[] { new Datum.Int(
											resultint) });
									return ret1;
								}

							}
							if (q3s.contains("true") || q3s.contains("false"))// ///AND,
																				// OR
							{
								if (q3s.contains("true")) {
									if (q3s.contains("false")) {
										if (q3s.contains("AND")) {
											boolean result = false;
											// ArrayList<Datum[]> ret = new
											// ArrayList<Datum[]>();
											ret1.add(new Datum[] { new Datum.Bool(
													result) });
											return ret1;
										} else if (q3s.contains("OR")) {
											boolean result = true;
											// ArrayList<Datum[]> ret = new
											// ArrayList<Datum[]>();
											ret1.add(new Datum[] { new Datum.Bool(
													result) });
											return ret1;
										}

									} else if (q3s.contains("NOT")) {
										boolean result = false;
										// ArrayList<Datum[]> ret = new
										// ArrayList<Datum[]>();
										ret1.add(new Datum[] { new Datum.Bool(
												result) });
										return ret1;
									} else {
										boolean result = true;
										// ArrayList<Datum[]> ret = new
										// ArrayList<Datum[]>();
										ret1.add(new Datum[] { new Datum.Bool(
												result) });
										return ret1;
									}

								} else// false
								{
									if (q3s.contains("NOT")) {
										boolean result = true;
										// ArrayList<Datum[]> ret = new
										// ArrayList<Datum[]>();
										ret1.add(new Datum[] { new Datum.Bool(
												result) });
										return ret1;
									} else {
										boolean result = false;
										// ArrayList<Datum[]> ret = new
										// ArrayList<Datum[]>();
										ret1.add(new Datum[] { new Datum.Bool(
												result) });
										return ret1;

									}
								}
							}
							if (q3s.contains("'")) {
								int a11 = q3s.indexOf("'");
								int b11 = q3s.indexOf("']");
								String colName1 = q3s.substring(a11 + 1, b11);

								// ArrayList<Datum[]> ret = new
								// ArrayList<Datum[]>();
								ret1.add(new Datum[] { new Datum.Str(colName1) });
								return ret1;

							}

							else if (q3s.contains("."))// /float number
							{
								int a11 = q3s.indexOf(":");
								int b11 = q3s.indexOf("]");
								String colName1 = q3s.substring(a11 + 1, b11);
								colName1 = colName1.trim();
								float f1 = Float.parseFloat(colName1);

								// ArrayList<Datum[]> ret = new
								// ArrayList<Datum[]>();
								ret1.add(new Datum[] { new Datum.Flt(f1) });
								return ret1;
							} else // /integer number
							{
								int a11 = q3s.indexOf(":");
								int b11 = q3s.indexOf("]");
								String colName1 = q3s.substring(a11 + 1, b11);
								colName1 = colName1.trim();
								int i4 = Integer.parseInt(colName1);
								// ArrayList<Datum[]> ret = new
								// ArrayList<Datum[]>();
								ret1.add(new Datum[] { new Datum.Int(i4) });
								return ret1;
							}

						}
					}
					break;
				case SELECT:

					int[] colIndex = new int[table.size()];
					String q4s = q1.detailString();
					// System.out.println(q4s);
					q4s = q4s.trim();
					char[] c = q4s.toCharArray();
					if (!q4s.contains("AND") && q4s.contains("OR")) {
						int iAnd = 0;
						int iOR = q4s.indexOf("OR");
						if (iAnd < iOR) { // regular expression
							Pattern p = Pattern.compile(".+((.+)OR(.+)).+");
							Matcher m = p.matcher(q4s);
							boolean bol = m.matches();
							// System.out.println(bol);// this tells us the
							// relations is and ( or )
							ArrayList names0 = new ArrayList();
							ArrayList rela = new ArrayList();

							for (int i11 = 0; i11 < c.length; i11++) {
								if (c[i11] == '=' || c[i11] == '>'
										|| c[i11] == '<') {
									rela.add(c[i11]);
								}
								if (c[i11] == '.') {
									names0.add(String.valueOf(c[i11 - 1]));
									names0.add(String.valueOf(c[i11 + 1]));
								}
							}
							int icolnames = indexpl.indexOf(10 * in + 1);
							String[] orderRange = (String[]) RANGENAMES
									.get(icolnames);// need the range names to
													// decide the order of < or
													// >
							String[] colnames = (String[]) COLNAMES
									.get(icolnames); // need the columnames
							String[][] arraytotal1 = (String[][]) data
									.get(icolnames);// need the data

							ArrayList<String[]> arraySelect = new ArrayList<String[]>(); // ///////revise
																							// the
																							// next
																							// part
																							// according
																							// to
																							// this
																							// one
							ArrayList location = new ArrayList();
							for (int i123 = 0; i123 < names0.size(); i123 = i123 + 2) {
								for (int i1234 = 0; i1234 < colnames.length; i1234++) {// find
																						// the
																						// locations
																						// of
																						// the
																						// relationships
									if (names0.get(i123).equals(
											orderRange[i1234])
											&& names0.get(i123 + 1).equals(
													colnames[i1234])) {
										location.add(i1234);
									}
								}
							}
							if (bol && rela.get(0).equals('>')
									&& rela.get(1).equals('<')) {
								for (int i11 = 0; i11 < arraytotal1.length; i11++) {
									if (((Integer
											.parseInt(arraytotal1[i11][Integer
													.parseInt(location.get(0)
															.toString())]) > Integer
											.parseInt((arraytotal1[i11][Integer
													.parseInt(location.get(1)
															.toString())]))) || (Integer
											.parseInt(arraytotal1[i11][Integer
													.parseInt(location.get(2)
															.toString())]) < Integer
											.parseInt((arraytotal1[i11][Integer
													.parseInt(location.get(3)
															.toString())]))))) { // ///////*******************2
																					// is
																					// the
																					// defaulted
																					// value,
																					// need
																					// change
																					// later
										arraySelect.add(arraytotal1[i11]);

									}
								}
							}
							String arrayjoin1[][] = new String[arraySelect
									.size()][arraySelect.get(0).length];// convert
																		// the
																		// arraylist
																		// format
																		// into
																		// the
																		// strring
																		// [][]
																		// format
							for (int i11 = 0; i11 < arraySelect.size(); i11++) {
								arrayjoin1[i11] = arraySelect.get(i11);
							}

							int i51 = indexpl.indexOf(in);
							indi[i51] = 1;

							// System.out.println("1");
							COLNAMES.set(i51, colnames);
							RANGENAMES.set(i51, orderRange);
							data.set(i51, arrayjoin1);

						} else if (iAnd > iOR) {

						}
					} else if (!q4s.contains("AND") && !q4s.contains("OR")) {
						// String [] l1=q4s.split("AND");
						// System.out.println(l1);
						ArrayList<String> colnames3 = new ArrayList();
						ArrayList<String> rannames3 = new ArrayList();
						int icol12 = 0;
						ArrayList names0 = new ArrayList();
						String rela0 = new String();
						char[] c2 = q4s.toCharArray();
						for (int i11 = 0; i11 < c2.length; i11++) { // got the
																	// index of
																	// '.'
							if (c2[i11] == '.') {
								names0.add(String.valueOf(c2[i11 - 1]));
								names0.add(String.valueOf(c2[i11 + 1]));
							}
						}
						if (q4s.contains("<")) {
							rela0 = "<";
						}

						// ArrayList names1=new ArrayList();
						// String rela1=new String ();
						//
						// int icolnames=indexpl.indexOf(10*in+1);
						// String [] orderRange=(String
						// [])RANGENAMES.get(icolnames);//need the range names
						// to decide the order of < or >
						// int leftR=0;
						// int rigR=0;
						// char [] c3=l1[1].toCharArray();
						// for (int i11=0;i11<c3.length;i11++){ //got the index
						// of '.'
						// if (c3[i11]=='.')
						// {
						// names1.add(String.valueOf(c3[i11-1]));
						// names1.add(String.valueOf(c3[i11+1]));
						//
						// }
						// }
						//
						// for (int iorder=0;iorder<orderRange.length;iorder++){
						// if
						// (orderRange[iorder].equals((String)names1.get(0))){
						// leftR=iorder;
						// break;
						// }
						// }
						// for (int iorder=0;iorder<orderRange.length;iorder++){
						// if
						// (orderRange[iorder].equals((String)names1.get(2))){
						// rigR=iorder;
						// break;
						// }
						// }
						// //leftR=orderRange.toString().indexOf((String)names1.get(0));
						// //rigR=orderRange.toString().indexOf((String)names1.get(1));
						//
						//
						//
						// if (l1[1].contains("="))
						// {
						// rela1="=";
						// }
						// else if (leftR<rigR && l1[1].contains("<")){
						// rela1="<";
						// }
						// else if (leftR>rigR && l1[1].contains("<")){
						// rela1=">";
						// }
						// else if (leftR<rigR && l1[1].contains(">")){
						// rela1=">";
						// }
						// else if (leftR>rigR && l1[1].contains(">")){
						// rela1="<";
						// }
						int i6 = indexpl.indexOf(in * 10 + 1);
						arraytotal = (String[][]) data.get(i6);
						String[] orderRange = (String[]) RANGENAMES.get(i6);// need
																			// the
																			// range
																			// names
																			// to
																			// decide
																			// the
																			// order
																			// of
																			// <
																			// or
																			// >
						String[] colnames = (String[]) COLNAMES.get(i6); // need
																			// the
																			// columnames
						ArrayList location0 = new ArrayList();
						// ArrayList location1=new ArrayList ();
						for (int i4 = 0; i4 < names0.size(); i4 = i4 + 2) {
							for (int i41 = 0; i41 < colnames.length; i41++) {
								if (colnames[i41].equals((String) names0
										.get(i4 + 1))
										&& orderRange[i41]
												.equals((String) names0.get(i4))) {
									location0.add(i41);

								}
							}
							// if (table.contains(names0.get(i4))){//range name
							//
							// i2=table.indexOf(names0.get(i4));
							// String str=(String)table.get(i2+1);
							// String str1=(String)table.get(i2+2);
							// if (colIndex[i2]==0){
							// colnames3.add(str);
							// rannames3.add((String)names0.get(i4));
							// icol12++;
							// colnames3.add(str1);
							// rannames3.add((String)names0.get(i4));
							// icol12++;
							// colIndex[i2]=1;}
							// if (names0.get(i4+1).equals(str)){
							// location0.add(1);
							// }
							//
							// else if (names0.get(i4+1).equals(str1)){
							// location0.add(2);
							// }
							// }
						}
						// if (leftR<rigR){
						// for (int i5=0;i5<names1.size();i5=i5+2){
						// if (table.contains(names1.get(i5))){//range name
						//
						// i2=table.indexOf(names1.get(i5));
						// String str=(String)table.get(i2+1);
						// String str1=(String)table.get(i2+2);
						// if (colIndex[i2]==0){
						// colnames3.add(str);
						// rannames3.add((String)names1.get(i5));
						// icol12++;
						// colnames3.add(str1);
						// rannames3.add((String)names1.get(i5));
						// icol12++;
						// colIndex[i2]=1;}
						// if (names1.get(i5+1).equals(str)){
						// location1.add(1);
						// }
						//
						// else if (names1.get(i5+1).equals(str1)){
						// location1.add(2);
						// }
						// }
						// }
						// }
						// else {
						// for (int i5=names1.size()-2;i5>=0;i5=i5-2){
						// if (table.contains(names1.get(i5))){//range name
						//
						// i2=table.indexOf(names1.get(i5));
						// String str=(String)table.get(i2+1);
						// String str1=(String)table.get(i2+2);
						// if (colIndex[i2]==0){
						// colnames3.add(str);
						// rannames3.add((String)names1.get(i5));
						// icol12++;
						// colnames3.add(str1);
						// rannames3.add((String)names1.get(i5));
						// icol12++;
						// colIndex[i2]=1;}
						// if (names1.get(i5+1).equals(str)){
						// location1.add(1);
						// }
						//
						// else if (names1.get(i5+1).equals(str1)){
						// location1.add(2);
						// }
						// }
						// }
						// }

						ArrayList<String[]> arraySelect = new ArrayList<String[]>();
						int i12 = 0;
						if (rela0 == "<") {
							for (int i11 = 0; i11 < arraytotal.length; i11++) {
								if (Integer
										.parseInt(arraytotal[i11][Integer
												.parseInt(location0.get(0)
														.toString())]) < Integer
										.parseInt((arraytotal[i11][Integer
												.parseInt(location0.get(1)
														.toString())]))) { // ///////*******************2
																			// is
																			// the
																			// defaulted
																			// value,
																			// need
																			// change
																			// later
									arraySelect.add(arraytotal[i11]);
									i12++;
								}
							}
						}
						// if (rela0=="=" && rela1=="<"){
						// for (int i11=0;i11<arraytotal.length;i11++){
						// if
						// (arraytotal[i11][Integer.parseInt(location0.get(0).toString())-1].equals(arraytotal[i11][1+Integer.parseInt(location0.get(1).toString())])
						// &&
						// Integer.parseInt(arraytotal[i11][Integer.parseInt(location1.get(0).toString())+1])<Integer.parseInt((arraytotal[i11][3+Integer.parseInt(location1.get(1).toString())]))){
						// /////////*******************2 is the defaulted value,
						// need change later
						// arraySelect.add(arraytotal[i11]);
						// i12++;
						// }
						// }
						// }
						// if (rela0=="=" && rela1==">"){
						// for (int i11=0;i11<arraytotal.length;i11++){
						// if
						// (arraytotal[i11][Integer.parseInt(location0.get(0).toString())-1].equals(arraytotal[i11][1+Integer.parseInt(location0.get(1).toString())])
						// &&
						// Integer.parseInt(arraytotal[i11][Integer.parseInt(location1.get(0).toString())+1])>Integer.parseInt((arraytotal[i11][3+Integer.parseInt(location1.get(1).toString())]))){
						// /////////*******************2 is the defaulted value,
						// need change later
						// arraySelect.add(arraytotal[i11]);
						// i12++;
						// }
						// }
						// }
						String arrayjoin1[][] = new String[i12][arraySelect
								.get(0).length];// convert the arraylist format
												// into the strring [][] format
						for (int i11 = 0; i11 < i12; i11++) {
							arrayjoin1[i11] = arraySelect.get(i11);
						}

						int i51 = indexpl.indexOf(in);
						indi[i51] = 1;
						//
						// String [] colnames231=new String [icol12];
						// for (int ij=0;ij<icol12;ij++){
						// colnames231[ij]=colnames3.get(ij);
						// }
						//
						// String [] ragnames231=new String [icol12];
						// for (int ij=0;ij<icol12;ij++){
						// ragnames231[ij]=rannames3.get(ij);
						// }

						// System.out.println("1");
						COLNAMES.set(i51, colnames);
						RANGENAMES.set(i51, orderRange);
						data.set(i51, arrayjoin1);

					} else {
						ArrayList<String> colnames1 = new ArrayList();
						ArrayList<String> ragnames1 = new ArrayList();
						int icol1 = 0;
						// System.out.println(sp[0]);
						// ArrayList dot=new ArrayList ();
						int leftdot = 0;
						int rightdot = 0;
						for (int i11 = 0; i11 < c.length; i11++) { // got the
																	// index of
																	// '.'
							if (c[i11] == '.') {
								if (leftdot == 0) {
									leftdot = i11;
								} else if (rightdot == 0) {
									rightdot = i11;
								}
							}
						}

						String leftRgename = String.valueOf(c[leftdot - 1]);
						String leftColname = String.valueOf(c[leftdot + 1]);

						String rigRgename = String.valueOf(c[rightdot - 1]);
						String rigColname = String.valueOf(c[rightdot + 1]);

						int l = 0;
						int r = 0;

						if (table.contains(leftRgename)) {

							i2 = table.indexOf(leftRgename);
							String str = (String) table.get(i2 + 1);
							String str1 = (String) table.get(i2 + 2);
							colnames1.add(str);
							ragnames1.add(leftRgename);
							icol1++;
							colnames1.add(str1);
							ragnames1.add(leftRgename);
							icol1++;
							if (leftColname.equals(str)) {
								l = 1;
							}

							else if (leftColname.equals(str1)) {
								l = 2;
							}
						}
						if (table.contains(rigRgename)) {

							i2 = table.indexOf(rigRgename);
							String str = (String) table.get(i2 + 1);
							String str1 = (String) table.get(i2 + 2);
							colnames1.add(str);
							ragnames1.add(rigRgename);
							icol1++;
							colnames1.add(str1);
							ragnames1.add(rigRgename);
							icol1++;
							if (rigColname.equals(str)) {
								r = 1;
							} else if (rigColname.equals(str1)) {
								r = 2;
							}
						}

						int i6 = indexpl.indexOf(in * 10 + 1);
						arraytotal = (String[][]) data.get(i6);
						ArrayList<String[]> arraySelect = new ArrayList<String[]>();
						int i12 = 0;
						if (q4s.contains(">")) {

						} else if (q4s.contains("=")) {
							for (int i11 = 0; i11 < arraytotal.length; i11++) {
								if (arraytotal[i11][l - 1]
										.equals(arraytotal[i11][1 + r])) { // ///////*******************2
																			// is
																			// the
																			// defaulted
																			// value,
																			// need
																			// change
																			// later
									arraySelect.add(arraytotal[i11]);
									i12++;
								}
							}
						} else if (q4s.contains("<")) {

						} else if (q4s.contains(">=")) {

						} else if (q4s.contains("<=")) {

						}
						String arrayjoin1[][] = new String[i12][arraySelect
								.get(0).length];// convert the arraylist format
												// into the strring [][] format
						for (int i11 = 0; i11 < i12; i11++) {
							arrayjoin1[i11] = arraySelect.get(i11);
						}

						int i51 = indexpl.indexOf(in);
						indi[i51] = 1;

						String[] colnames231 = new String[icol1];
						for (int ij = 0; ij < icol1; ij++) {
							colnames231[ij] = colnames1.get(ij);
						}

						String[] ragnames231 = new String[icol1];
						for (int ij = 0; ij < icol1; ij++) {
							ragnames231[ij] = ragnames1.get(ij);
						}

						// System.out.println("1");
						COLNAMES.set(i51, colnames231);
						RANGENAMES.set(i51, ragnames231);
						data.set(i51, arrayjoin1);
					}// replace the original information in the data associated
						// with node
					break;

				case JOIN:
					String q4s1 = q1.detailString();
					String arrayleft[][] = new String[0][0];
					String arrayright[][] = new String[0][0];
					ArrayList<String> colnames = new ArrayList();
					ArrayList<String> ragnames = new ArrayList();
					int icol = 0;
					if (table.contains(in * 10 + 1)) {
						i2 = table.indexOf(in * 10 + 1);
						colnames.add((String) table.get(i2 + 2));
						ragnames.add((String) table.get(i2 + 1));
						icol++;
						colnames.add((String) table.get(i2 + 3));
						ragnames.add((String) table.get(i2 + 1));
						icol++;
						Schema.TableFromFile table_R1 = tables.get(table
								.get(i2 + 1));
						String pathadd1 = table_R1.getFile().toString();
						Readtable_old readr1 = new Readtable_old();
						arrayleft = readr1.readfile(pathadd1);
					} else {

						i2 = indexpl.indexOf(in * 10 + 1);
						String[][] preArray = (String[][]) data.get(i2);
						String[] preColname = (String[]) COLNAMES.get(i2);
						String[] preRagname = (String[]) RANGENAMES.get(i2);
						for (int i143 = 0; i143 < preColname.length; i143++) {
							colnames.add(preColname[i143]);
							ragnames.add(preRagname[i143]);
							icol++;
						}
						arrayleft = preArray;
					}

					if (table.contains(in * 10 + 2)) {
						i2 = table.indexOf(in * 10 + 2);
						colnames.add((String) table.get(i2 + 2));
						ragnames.add((String) table.get(i2 + 1));
						icol++;
						colnames.add((String) table.get(i2 + 3));
						ragnames.add((String) table.get(i2 + 1));
						icol++;
						Schema.TableFromFile table_R2 = tables.get(table
								.get(i2 + 1));
						String pathadd2 = table_R2.getFile().toString();
						Readtable_old readr2 = new Readtable_old();
						arrayright = readr2.readfile(pathadd2);
					} else {
						i2 = indexpl.indexOf(in * 10 + 1);
						String[][] preArray = (String[][]) data.get(i2);
						String[] preColname = (String[]) COLNAMES.get(i2);
						String[] preRagname = (String[]) RANGENAMES.get(i2);
						for (int i143 = 0; i143 < preColname.length; i143++) {
							colnames.add(preColname[i143]);
							ragnames.add(preRagname[i143]);
							icol++;
						}
						arrayright = preArray;
					}

					int jleftnum = 0;
					int jrightnum = 0;

					jleftnum = arrayleft[0].length;
					jrightnum = arrayright[0].length;

					String arrayjoin[][] = new String[arrayleft.length
							* arrayright.length][jleftnum + jrightnum];
					ArrayList<String[]> arrayjoin1 = new ArrayList<String[]>();
					if (q4s1.contains("SORT")) {
						String q4s2 = q4s1.replace(" ", "");
						q4s2 = q4s2.replace("JOIN", "");
						q4s2 = q4s2.replace("SORTMERGE", "");
						q4s2 = q4s2.replace("[", "");
						q4s2 = q4s2.replace("]", "");
						q4s2 = q4s2.replace("(", "");
						q4s2 = q4s2.replace(")", "");
						q4s2 = q4s2.replace(";", "");
						String[] q4s3 = q4s2.split("=");
						int left = 0;
						int rig = 0;
						// for (int i11=0;i11<q4s3.length;i11++){
						for (int i12 = 0; i12 < colnames.size(); i12++) {
							if (q4s3[0].contains((String) colnames.get(i12))
									&& q4s3[0].contains((String) ragnames
											.get(i12))) {
								left = i12;
							}
						}
						for (int i12 = 0; i12 < colnames.size(); i12++) {
							if (q4s3[1].contains((String) colnames.get(i12))
									&& q4s3[1].contains((String) ragnames
											.get(i12))) {
								rig = i12;
							}
						}
						// }
						for (i = 0; i < arrayleft.length; i++) // join the two
																// tables
						{

							for (j = 0; j < arrayright.length; j++) {
								if (arrayleft[i][left].equals(arrayright[j][rig
										- arrayleft[0].length])) {
									String[] arrayjoin2 = new String[arrayleft[0].length
											* arrayright[0].length];
									for (int k = 0; k < arrayleft[0].length; k++) {
										arrayjoin2[k] = arrayleft[i][k];
									}
									for (int k = 0; k < arrayright[0].length; k++) {
										arrayjoin2[arrayleft[0].length + k] = arrayright[j][k];
									}
									arrayjoin1.add(arrayjoin2);
								}
							}
						}
						arrayjoin = new String[arrayjoin1.size()][arrayleft[0].length
								* arrayright[0].length];
						for (int i13 = 0; i13 < arrayjoin1.size(); i13++) {
							arrayjoin[i13] = (String[]) arrayjoin1.get(i13);
						}
					} else {
						for (i = 0; i < arrayleft.length; i++) // join the two
																// tables
						{

							for (j = 0; j < arrayright.length; j++) {
								for (int k = 0; k < arrayleft[0].length; k++) {
									arrayjoin[i * arrayright.length + j][k] = arrayleft[i][k];
								}
								for (int k = 0; k < arrayright[0].length; k++) {
									arrayjoin[i * arrayright.length + j][arrayleft[0].length
											+ k] = arrayright[j][k];
								}
							}
						}
					}
					int i5 = indexpl.indexOf(in);
					indi[i5] = 1;
					String[] colnames23 = new String[icol];
					for (int ij = 0; ij < icol; ij++) {
						colnames23[ij] = colnames.get(ij);
					}

					String[] ragnames23 = new String[icol];
					for (int ij = 0; ij < icol; ij++) {
						ragnames23[ij] = ragnames.get(ij);
					}

					COLNAMES.set(i5, colnames23);
					RANGENAMES.set(i5, ragnames23);
					data.set(i5, arrayjoin); // replace the original information
												// in the data associated with
												// node
					jointimes++;

					break;
				case NULLSOURCE:
					break;
				case UNION:

					int leftU = indexpl.indexOf(10 * in + 1);
					int rigU = indexpl.indexOf(10 * in + 2);

					int uupnum = 0;
					int udownnum = 0;
					String arrayup[][] = (String[][]) data.get(leftU);
					String arraydown[][] = (String[][]) data.get(rigU);
					uupnum = arrayup[0].length;
					udownnum = arraydown[0].length;

					String arrayunion[][] = new String[arrayup.length
							+ arraydown.length][uupnum];

					for (i = 0; i < arrayup.length; i++) {
						for (j = 0; j < arrayup[i].length; j++)
							arrayunion[i][j] = arrayup[i][j];
					}
					for (i = 0; i < arraydown.length; i++) {
						for (j = 0; j < arraydown[i].length; j++)
							arrayunion[arrayup.length + i][j] = arraydown[i][j];
					}
					int iUnion = indexpl.indexOf(in);
					data.set(iUnion, arrayunion);
					if (in == 1) {
						ArrayList<Datum[]> ret3 = new ArrayList<Datum[]>();
						for (int i7 = 0; i7 < arrayunion.length; i7++) {
							Datum[] ret113 = new Datum[arrayunion[0].length];// now
																				// the
																				// datum
																				// []
																				// lenth
																				// is
																				// the
																				// number
																				// of
																				// calculations
							for (int i13 = 0; i13 < arrayunion[0].length; i13++) {
								ret113[i13] = new Datum.Int(
										Integer.parseInt(arrayunion[i7][i13]));
							}
							ret3.add(ret113);// each row is a datum [] type
							// ret3.add(new Datum[] {new
							// Datum.Int(Integer.parseInt(arrayunion[i7][0]))});
						}
						return ret3;
					}
					break;

				}
				// }

				// }

			}
		} else if (mark == 2) {
			ArrayList<PlanNode> pl = new ArrayList<PlanNode>(); // the arraylist
			// records the nodes
			// of the tree [1]
			ArrayList indexpl = new ArrayList(); // the arraylist records the
			// structure of the tree [2]
			int root = 1;
			int i = 0;
			int j = 0;
			int j0 = 1;
			int in = 0;// index in the tree
			pl.add(q);
			indexpl.add(root);// recording the tree relationship
			PlanNode q1;
			PlanNode q3;
			PlanNode ql;
			PlanNode qr;

			while (j0 > j)// no new nodes are found
			{
				int num = 0;
				int jold = j;
				for (int k = j + 1; k <= j0; k++) {
					q1 = pl.get(k - 1);
					in = (Integer) indexpl.get(k - 1);
					int m = 1;
					switch (q1.type) {
					case AGGREGATE:
						j = pl.size();
						AggregateNode q2 = (AggregateNode) q1;
						q3 = q2.getChild();
						pl.add(q3);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case PROJECT:
						j = pl.size();
						ProjectionNode q21 = (ProjectionNode) q1;
						q3 = q21.getChild();
						pl.add(q3);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case SELECT:
						j = pl.size();
						SelectionNode q22 = (SelectionNode) q1;
						q3 = q22.getChild();
						pl.add(q3);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case JOIN:
						j = pl.size();
						JoinNode q23 = (JoinNode) q1;
						ql = q23.getLHS();
						qr = q23.getRHS();
						pl.add(ql);
						indexpl.add(in * 10 + m);
						m = m + 1;
						pl.add(qr);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case UNION:
						j = pl.size();
						UnionNode q25 = (UnionNode) q1;
						ql = q25.getLHS();
						qr = q25.getRHS();
						pl.add(ql);
						indexpl.add(in * 10 + m);
						m = m + 1;
						pl.add(qr);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case NULLSOURCE:
						j = pl.size();
						indexpl.add(in * 10 + m);
						m = m + 1;
						// i=1;
						break;
					case SCAN:
						// j=pl.size();
						// indexpl.add(in*10+m);
						num = num + 1;
						break;
					}
				}
				if (num == j0 - jold) {
					break;
				}
				j0 = pl.size();
			}
			int s = pl.size();
			int jointimes = 0;
			int indi[] = new int[s];// if the child node has provided some
									// useful
			// information
			ArrayList data = new ArrayList();// the third arraylist, which
												// records
			// the data associated with node [3]
			ArrayList COLNAMES = new ArrayList();// record the column names of
													// the
			// arraylist in "data" (the
			// former row) [4]
			ArrayList RANGENAMES = new ArrayList();// record the range names of
													// the
			// arraylist in "data" [5]
			for (int k1 = 0; k1 < s; k1++) {
				ArrayList<String[]> data1 = new ArrayList();
				data.add(data1);
				COLNAMES.add(data1);
				RANGENAMES.add(data1);
			}
			ArrayList table = new ArrayList();// from bottom to the top,
												// previously
			// from top to the bottom
			for (int k5 = s; k5 >= 1; k5--) {
				// if (indi[k]==0){
				in = (Integer) indexpl.get(k5 - 1);
				// if (indexpl.contains(in-1))// this is one of the binary child
				// nodes
				// {}
				// else //this is a unary child node or its father node is unary
				// {
				q1 = pl.get(k5 - 1);

				switch (q1.type) {
				case SCAN:
					String q1s = q1.detailString();
					if (q1s.contains(";"))// push down
					{

						String[] q1s_pushdown = q1s.split(";");
						if (q1s_pushdown.length == 3) {//index scan
							byte[] B1 = q1s_pushdown[1].getBytes();
							byte[] B2 = q1s_pushdown[2].getBytes();
							int b = q1s_pushdown[2].indexOf("(");
							int b1 = q1s_pushdown[2].indexOf("(");
							int c1 = q1s_pushdown[2].indexOf(")");

							ArrayList col11 = new ArrayList();

							ArrayList index = new ArrayList();
							for (int in1 = 0; in1 < B2.length; in1++) {
								if (B2[in1] == ',') {
									index.add(in1);
								}
							}
							int a = q1s_pushdown[1].indexOf("(");
							String rangeVar = q1s_pushdown[2].substring(0, b);
							table.add(in);
							table.add(rangeVar);

							// range names
							String[] raname = rangeVar.toLowerCase().split("");
							String[] raname1 = new String[1];
							raname1[0] = raname[1];

							int c22 = (int) index.get(0);
							String col1 = q1s_pushdown[2]
									.substring(b1 + 1, c22);
							table.add(col1);
							col11.add(raname[1]);
							col11.add(col1);
							for (int in1 = 1; in1 < index.size(); in1++) {
								col1 = q1s_pushdown[2].substring(
										(int) index.get(in1 - 1) + 2,
										(int) index.get(in1));
								table.add(col1);
								col11.add(raname[1]);
								col11.add(col1);
							}
							col1 = q1s_pushdown[2].substring(
									(int) index.get(index.size() - 1) + 2, c1);
							table.add(col1);
							col11.add(raname[1]);
							col11.add(col1);

							// column names
							String[] colname = new String[col11.size()];
							for (int i111 = 0; i111 < col11.size(); i111++) {
								colname[i111] = (String) col11.get(i111);
							}

							Schema.TableFromFile table_R123 = tables
									.get(rangeVar);
							String pathadd123 = table_R123.getFile().toString();
							Readtable readr123 = new Readtable();// edu.buffalo.cse.sql.io
							String arraytotal12[][] = readr123.readfile("test/"
									+ pathadd123);

							// consider the select condition in SCAN
							ArrayList left = new ArrayList();
							ArrayList right = new ArrayList();
							ArrayList tord = new ArrayList(); // from table or
																// the
																// real
							ArrayList indexfilename = new ArrayList(); // the
																		// name
																		// of
																		// the
																		// index
																		// file,
																		// for
																		// index
																		// scan
							// data 1 or 0
							ArrayList calcu = new ArrayList(); // record the
							// 1:"=";2,"<";3,">";4:">=";5"<="
							// if (q1s_pushdown[0].contains("<=")){
							// String [] q4s2 = q1s_pushdown[0].split("<=");
							// int ins = 0;
							// for (int u = 0; u < colname.length; u = u + 2) {
							// if (q4s2[0].contains(colname[u])
							// && q4s2[0].contains(colname[u + 1])) {
							// ins = u / 2;
							// }
							// }
							// left.add(ins);
							//
							// ins = 0;
							// for (int u = 0; u < colname.length; u = u + 2) {
							// if (q4s2[1].contains(colname[u])
							// && q4s2[1].contains(colname[u + 1])) {
							// ins = u / 2;
							// }
							// }
							// if (ins != 0) {
							// right.add(ins);
							// tord.add(1);
							// } else if (ins == 0) {
							// String sdot = q4s2[1].substring(
							// q4s2[1].indexOf("<=") + 2,
							// q4s2[1].length()-1);
							// if (sdot.contains("+")) {
							// int s6 = sdot.indexOf("+");
							// int sle = Integer.parseInt(sdot.substring(
							// 0, s6));
							// int sri = Integer.parseInt(sdot.substring(
							// s6 + 1, sdot.length()));
							//
							// sdot = Integer.toString(sle + sri);
							// }
							// right.add(sdot);
							// tord.add(0);
							// }
							// calcu.add(5);
							// }
							String q4s = q1s_pushdown[1];
							q4s = q4s.replace(" ", "");
							q4s = q4s.replace("SCAN", "");
							q4s = q4s.replace("[", "");
							q4s = q4s.replace("]", "");
							q4s = q4s.replace("(", "");
							q4s = q4s.replace(")", "");
							ArrayList q4s1 = new ArrayList();
							String[] q4s20 = q4s.split("AND");
							for (int s1 = 0; s1 < q4s20.length; s1++) {
								String[] q4s3 = q4s20[s1].split("OR");
								for (int s2 = 0; s2 < q4s3.length; s2++) {
									q4s1.add(q4s3[s2]);
								}
							}
							// transfer the arraylist into string []
							String[] q4s3 = new String[q4s1.size()];
							for (int s3 = 0; s3 < q4s3.length; s3++) {
								q4s3[s3] = (String) q4s1.get(s3);
							}

							// String [] q4s3=new String [1];
							// q4s3[0]=q1s_pushdown[0];
							String[] q4s2;
							for (int s1 = 0; s1 < q4s3.length; s1++) {
								if (q4s3[s1].contains("=")
										&& !q4s3[s1].contains(">")
										&& !q4s3[s1].contains("<")) {
									q4s2 = q4s3[s1].split("=");
									int ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[0].contains(colname[u])
												&& q4s2[0]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									left.add(ins);

									ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[1].contains(colname[u])
												&& q4s2[1]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									if (ins != 0) {
										right.add(ins);
										tord.add(1);
									} else if (ins == 0) {
										int idot = q4s2[1].indexOf("'");
										String sdot = q4s2[1].substring(
												idot + 1, q4s2[1].length() - 1);
										right.add(sdot);
										tord.add(0);
									}
									calcu.add(1);
								} else if (q4s3[s1].contains("<")
										&& !q4s3[s1].contains("<=")) {
									q4s2 = q4s3[s1].split("<");
									int ins = 0;
									String filename = "";
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[0].contains(colname[u])
												&& q4s2[0]
														.contains(colname[u + 1])) {
											ins = u / 2;
											filename = (String) colname[u]
													+ "_"
													+ (String) colname[u + 1]
													+ ".dat";// for the index
																// file name
										}
									}
									left.add(ins);
									indexfilename.add(filename);

									ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[1].contains(colname[u])
												&& q4s2[1]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									if (ins != 0) {
										right.add(ins);
										tord.add(1);
									} else if (ins == 0) {
										String sdot = q4s2[1].substring(
												q4s2[1].indexOf("<") + 1,
												q4s2[1].length());
										right.add(sdot);
										tord.add(0);
									}
									calcu.add(2);
								} else if (q4s3[s1].contains("<=")) {
									q4s2 = q4s3[s1].split("<=");
									int ins = 0;
									String filename = "";
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[0].contains(colname[u])
												&& q4s2[0]
														.contains(colname[u + 1])) {
											ins = u / 2;
											filename = (String) colname[u]
													+ "_"
													+ (String) colname[u + 1]
													+ ".dat";// for the index
																// file name
										}
									}
									left.add(ins);
									indexfilename.add(filename);

									ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[1].contains(colname[u])
												&& q4s2[1]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									if (ins != 0) {
										right.add(ins);
										tord.add(1);
									} else if (ins == 0) {
										String sdot = q4s2[1].substring(
												q4s2[1].indexOf("<=") + 1,
												q4s2[1].length());
										if (sdot.contains("+")) {
											int s6 = sdot.indexOf("+");
											int sle = Integer.parseInt(sdot
													.substring(0, s6));
											int sri = Integer.parseInt(sdot
													.substring(s6 + 1,
															sdot.length()));

											sdot = Integer.toString(sle + sri);
										}
										right.add(sdot);
										tord.add(0);
									}
									calcu.add(5);
								} else if (q4s3[s1].contains(">")
										&& !q4s3[s1].contains(">=")) {
									q4s2 = q4s3[s1].split(">");
									int ins = 0;
									String filename = "";
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[0].contains(colname[u])
												&& q4s2[0]
														.contains(colname[u + 1])) {
											ins = u / 2;
											filename = (String) colname[u]
													+ "_"
													+ (String) colname[u + 1]
													+ ".dat";// for the index
																// file name
										}
									}
									left.add(ins);
									indexfilename.add(filename);

									ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[1].contains(colname[u])
												&& q4s2[1]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									if (ins != 0) {
										right.add(ins);
										tord.add(1);
									} else if (ins == 0) {
										String sdot = q4s2[1].substring(
												q4s2[1].indexOf(">") + 1,
												q4s2[1].length());
										right.add(sdot);
										tord.add(0);
									}
									calcu.add(3);
								} else if (q4s3[s1].contains(">=")) {
									q4s2 = q4s3[s1].split(">=");
									int ins = 0;
									String filename = "";
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[0].contains(colname[u])
												&& q4s2[0]
														.contains(colname[u + 1])) {
											ins = u / 2;
											filename = (String) colname[u]
													+ "_"
													+ (String) colname[u + 1]
													+ ".dat";// for the index
																// file name
										}
									}
									left.add(ins);
									indexfilename.add(filename);

									ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[1].contains(colname[u])
												&& q4s2[1]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									if (ins != 0) {
										right.add(ins);
										tord.add(1);
									} else if (ins == 0) {
										String sdot = q4s2[1].substring(
												q4s2[1].indexOf(">=") + 1,
												q4s2[1].length());
										right.add(sdot);
										tord.add(0);
									}
									calcu.add(4);
								}
							}
							ArrayList<String[]> finalresults = new ArrayList<String[]>();
							ArrayList<String[]> test1 = new ArrayList<String[]>();
							for (int se3 = 0; se3 < arraytotal12.length; se3++) {
								test1.add(arraytotal12[se3]);
							}
							// String [][] test1=arraySELECT;
							// scan from to 
							if (left.size() == 2
									&& left.get(0).equals(left.get(1))
									&& (int) calcu.get(0) == 2
									&& (int) calcu.get(1) == 4) {
								// use index scan from to
								
								
								int keyorder = (int) left.get(0);// create key
								// by order
								File idxFile = new File(
										(String) indexfilename.get(0));
								ManagedFile file;
								TestDataStream ds = new TestDataStream(keys,
										values, rows, keychaos, true);
								IndexKeySpec keySpec = new GenericIndexKeySpec(
										ds.getSchema(), keys, keyorder);// revised
								Iterator<Datum[]> scan = null;
								try {
									file = fm.open(idxFile);
									IndexFile idx = new ISAMIndex(file, keySpec);
									
									fm.close(idxFile);
									Datum[] from = new Datum[1];
									from[0] = new Datum.Int(
											Integer.parseInt((String) right
													.get(1)));
									Datum[] to = new Datum[1];
									to[0] = new Datum.Int(
											Integer.parseInt((String) right
													.get(0)) - 1);
									scan = idx.rangeScan(from, to);
								} catch (IOException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								ArrayList neworder =new ArrayList (); // this is ordered to produce the index
								while (scan.hasNext()) {
									Datum[] da1 = scan.next();
									neworder.add(da1[1].toString());
								}
								int [] oldorder=new int [neworder.size()];
								for (int old=0;old<neworder.size();old++){
									oldorder[old]=Integer.parseInt(neworder.get(old).toString());
								}
								Arrays.sort(oldorder);
								String []test2 = null;
								for (int old1=0;old1<oldorder.length;old1++){
								test2 = test1.get(oldorder[old1]);// the
								finalresults.add(test2);}
								// second
								// column
								// is
								// the
								// row
								// order
								// in
								// the
								// original
								// data
								test1 = finalresults;
							}
							else if (left.size() == 2
									&& left.get(0).equals(left.get(1))
									&& (int) calcu.get(0) == 4
									&& (int) calcu.get(1) == 2){
								// use index scan from to
//								IndexType type = IndexType.ISAM;
//								int keys = 1;// the size of the key
//								int values = 5;// the size of the value so
//												// keys+values size is the size
//												// of one row
//								int rows = 100;
//								int frames = 1024;// the size of neicun
//								int keychaos = 2;// the randomness of the key
//								int indexSize = 10;// for hash
								int keyorder = (int) left.get(0);// create key
																	// by order
//								BufferManager bm = new BufferManager(frames);
//								FileManager fm = new FileManager(bm);

								File idxFile = new File(
										(String) indexfilename.get(0));
								ManagedFile file;
								TestDataStream ds = new TestDataStream(keys,
										values, rows, keychaos, true);
								IndexKeySpec keySpec = new GenericIndexKeySpec(
										ds.getSchema(), keys, keyorder);// revised
								Iterator<Datum[]> scan = null;
								try {
									file = fm.open(idxFile);
									IndexFile idx = new ISAMIndex(file, keySpec);
									fm.close(idxFile);
									Datum[] from = new Datum[1];
									from[0] = new Datum.Int(
											Integer.parseInt((String) right
													.get(0)));
									Datum[] to = new Datum[1];
									to[0] = new Datum.Int(
											Integer.parseInt((String) right
													.get(1)) - 1);
									scan = idx.rangeScan(from, to);
								} catch (IOException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
								ArrayList neworder =new ArrayList (); // this is ordered to produce the index, but order
								while (scan.hasNext()) {
									Datum[] da1 = scan.next();
									neworder.add(da1[1].toString());
								}
								int [] oldorder=new int [neworder.size()];
								for (int old=0;old<neworder.size();old++){
									oldorder[old]=Integer.parseInt(neworder.get(old).toString());
								}
								Arrays.sort(oldorder);
								String []test2 = null;
								for (int old1=0;old1<oldorder.length;old1++){
								test2 = test1.get(oldorder[old1]);// the
								finalresults.add(test2);}
								
								test1 = finalresults;
								
							}
							else if (left.size() == 5
									&& left.get(0).equals(left.get(1))
									&& (int) calcu.get(0) == 2
									&& (int) calcu.get(1) == 4){
//								IndexType type = IndexType.ISAM;
//								int keys = 1;// the size of the key
//								int values = 5;// the size of the value so
//												// keys+values size is the size
//												// of one row
//								int rows = 100;
//								int frames = 1024;// the size of neicun
//								int keychaos = 2;// the randomness of the key
//								int indexSize = 10;// for hash
								int keyorder = (int) left.get(0);// create key
																	// by order
//								BufferManager bm = new BufferManager(frames);
//								FileManager fm = new FileManager(bm);

								File idxFile = new File(
										(String) indexfilename.get(0));
								ManagedFile file;
								TestDataStream ds = new TestDataStream(keys,
										values, rows, keychaos, true);
								IndexKeySpec keySpec = new GenericIndexKeySpec(
										ds.getSchema(), keys, keyorder);// revised
								Iterator<Datum[]> scan = null;
								try {
									file = fm.open(idxFile);
									IndexFile idx = new ISAMIndex(file, keySpec);
									fm.close(idxFile);
									Datum[] from = new Datum[1];
									from[0] = new Datum.Int(
											Integer.parseInt((String) right
													.get(1)));
									Datum[] to = new Datum[1];
									to[0] = new Datum.Int(
											Integer.parseInt((String) right
													.get(0)) - 1);
									scan = idx.rangeScan(from, to);
								} catch (IOException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
								ArrayList neworder =new ArrayList (); // this is ordered to produce the index, 
								while (scan.hasNext()) {
									Datum[] da1 = scan.next();
									neworder.add(da1[1].toInt());
								}
								int [] oldorder=new int [neworder.size()];
								for (int old=0;old<neworder.size();old++){
									oldorder[old]=Integer.parseInt(neworder.get(old).toString());
								}
								Arrays.sort(oldorder);
								for (int old1=0;old1<oldorder.length;old1++){
								String []test2 = test1.get(oldorder[old1]);// the
								finalresults.add(test2);}
								
								test1 = finalresults;
								finalresults = new ArrayList<String[]>();
								// the third and fourth
								for (int se2 = 0; se2 < calcu.size(); se2++) {
									if ((int) calcu.get(se2) == 1) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1.size(); se1++) {
												String[] test2 = test1.get(se1);
												if (test2[(int) left.get(se2)]
														.equals((String) right.get(se2))) {
													finalresults.add(test2);
												}
											}
										} else if ((int) tord.get(se2) == 1) {
											for (int se1 = 0; se1 < test1.size(); se1++) {
												String[] test2 = test1.get(se1);
												if (test2[(int) left.get(se2)]
														.equals(test2[(int) right
																.get(se2)])) {
													finalresults.add(test2);
												}
											}
										}
									} else if ((int) calcu.get(se2) == 2) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");
												if (!test3.contains(".")) {
													int test4 = Integer.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 < test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 < test5) {
														finalresults.add(test2);
													}
												}

											}
										}
									} else if ((int) calcu.get(se2) == 3) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");
												if (!test3.contains(".")) {
													int test4 = Integer.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 > test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 > test5) {
														finalresults.add(test2);
													}
												}

											}
										}
									} else if ((int) calcu.get(se2) == 4) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");

												if (!test3.contains(".")) {
													int test4 = Integer.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 > test5 || test4 == test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 > test5 || test4 == test5) {
														finalresults.add(test2);
													}
												}
											}
										}
									} else if ((int) calcu.get(se2) == 5) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");

												if (!test3.contains(".")) {
													int test4 = Integer.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 < test5 || test4 == test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 < test5 || test4 == test5) {
														finalresults.add(test2);
													}
												}
											}
										}
									}

									test1 = finalresults;
									finalresults = new ArrayList<String[]>();
								}
							}
							else {
								for (int se2 = 0; se2 < calcu.size(); se2++) {
									if ((int) calcu.get(se2) == 1) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												if (test2[(int) left.get(se2)]
														.equals((String) right
																.get(se2))) {
													finalresults.add(test2);
												}
											}
										} else if ((int) tord.get(se2) == 1) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												if (test2[(int) left.get(se2)]
														.equals(test2[(int) right
																.get(se2)])) {
													finalresults.add(test2);
												}
											}
										}
									} else if ((int) calcu.get(se2) == 2) {
										if ((int) tord.get(se2) == 0) {
//											IndexType type = IndexType.ISAM;
//											int keys = 1;// the size of the key
//											int values = 5;// the size of the
//															// value so
//															// keys+values size
//															// is the size of
//															// one row
//											int rows = 100;
//											int frames = 1024;// the size of
//																// neicun
//											int keychaos = 2;// the randomness
//																// of the key
//											int indexSize = 10;// for hash
											int keyorder = (int) left.get(se2);// create
																				// key
																				// by
																				// order
//											BufferManager bm = new BufferManager(
//													frames);
//											FileManager fm = new FileManager(bm);

											File idxFile = new File(
													(String) indexfilename
															.get(se2));
											ManagedFile file;
											TestDataStream ds = new TestDataStream(
													keys, values, rows,
													keychaos, true);
											IndexKeySpec keySpec = new GenericIndexKeySpec(
													ds.getSchema(), keys,
													keyorder);// revised
											Iterator<Datum[]> scan = null;
											try {
												file = fm.open(idxFile);
												IndexFile idx = new ISAMIndex(
														file, keySpec);
												fm.close(idxFile);
												Datum[] to = new Datum[1];
												to[0] = new Datum.Int(
														Integer.parseInt((String) right
																.get(se2)) - 1);
												scan = idx.rangeScanTo(to);
											} catch (IOException e) {
												// TODO Auto-generated catch
												// block
												e.printStackTrace();
											}
											
											ArrayList neworder =new ArrayList (); // this is ordered to produce the index, but 
											while (scan.hasNext()) {
												Datum[] da1 = scan.next();
												neworder.add(da1[1].toString());
											}
											int [] oldorder=new int [neworder.size()];
											for (int old=0;old<neworder.size();old++){
												oldorder[old]=Integer.parseInt(neworder.get(old).toString());
											}
											Arrays.sort(oldorder);
											String []test2 = null;
											for (int old1=0;old1<oldorder.length;old1++){
											test2 = test1.get(oldorder[old1]);// the
											finalresults.add(test2);}
											// for (int se1 = 0; se1 <
											// test1.size(); se1++) {
											// String[] test2 = test1.get(se1);
											// String test3 = test2[(int) left
											// .get(se2)];
											// test3 = test3.replace("-", "");
											// if (!test3.contains(".")) {
											// int test4 =
											// Integer.parseInt(test3);
											// int test5 = Integer
											// .parseInt((String) right
											// .get(se2));
											// if (test4 < test5) {
											// finalresults.add(test2);
											// }
											// } else if (test3.contains(".")) {
											// float test4 = Float
											// .parseFloat(test3);
											// float test5 = Float
											// .parseFloat((String) right
											// .get(se2));
											// if (test4 < test5) {
											// finalresults.add(test2);
											// }
											// }
											//
											// }
										}
									} else if ((int) calcu.get(se2) == 3) {
										if ((int) tord.get(se2) == 0) {
//											IndexType type = IndexType.ISAM;
//											int keys = 1;// the size of the key
//											int values = 5;// the size of the
//															// value so
//															// keys+values size
//															// is the size of
//															// one row
//											int rows = 100;
//											int frames = 1024;// the size of
//																// neicun
//											int keychaos = 2;// the randomness
//																// of the key
//											int indexSize = 10;// for hash
											int keyorder = (int) left.get(se2);// create
																				// key
																				// by
																				// order
//											BufferManager bm = new BufferManager(
//													frames);
//											FileManager fm = new FileManager(bm);

											File idxFile = new File(
													(String) indexfilename
															.get(se2));
											ManagedFile file;
											TestDataStream ds = new TestDataStream(
													keys, values, rows,
													keychaos, true);
											IndexKeySpec keySpec = new GenericIndexKeySpec(
													ds.getSchema(), keys,
													keyorder);// revised
											Iterator<Datum[]> scan = null;
											try {
												file = fm.open(idxFile);
												IndexFile idx = new ISAMIndex(
														file, keySpec);
												fm.close(idxFile);
												Datum[] from = new Datum[1];
												from[0] = new Datum.Int(
														Integer.parseInt((String) right
																.get(se2)) + 1);// >
																				// one
																				// number
																				// equals
																				// >=one
																				// number
																				// +1
												scan = idx.rangeScanFrom(from);
											} catch (IOException e) {
												// TODO Auto-generated catch
												// block
												e.printStackTrace();
											}
											
											ArrayList neworder =new ArrayList (); // this is ordered to produce the index, but 
											while (scan.hasNext()) {
												Datum[] da1 = scan.next();
												neworder.add(da1[1].toString());
											}
											int [] oldorder=new int [neworder.size()];
											for (int old=0;old<neworder.size();old++){
												oldorder[old]=Integer.parseInt(neworder.get(old).toString());
											}
											Arrays.sort(oldorder);
											String []test2 = null;
											for (int old1=0;old1<oldorder.length;old1++){
											test2 = test1.get(oldorder[old1]);// the
											finalresults.add(test2);}
											// for (int se1 = 0; se1 <
											// test1.size(); se1++) {
											// String[] test2 = test1.get(se1);
											// String test3 = test2[(int) left
											// .get(se2)];
											// test3 = test3.replace("-", "");
											// if (!test3.contains(".")) {
											// int test4 =
											// Integer.parseInt(test3);
											// int test5 = Integer
											// .parseInt((String) right
											// .get(se2));
											// if (test4 > test5) {
											// finalresults.add(test2);
											// }
											// } else if (test3.contains(".")) {
											// float test4 = Float
											// .parseFloat(test3);
											// float test5 = Float
											// .parseFloat((String) right
											// .get(se2));
											// if (test4 > test5) {
											// finalresults.add(test2);
											// }
											// }
											//
											// }
										}
									} else if ((int) calcu.get(se2) == 4) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");

												if (!test3.contains(".")) {
													int test4 = Integer
															.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 > test5
															|| test4 == test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 > test5
															|| test4 == test5) {
														finalresults.add(test2);
													}
												}
											}
										}
									} else if ((int) calcu.get(se2) == 5) {
										if ((int) tord.get(se2) == 0) {
											// revise because we want to use
											// index here
//											IndexType type = IndexType.ISAM;
//											int keys = 1;// the size of the key
//											int values = 5;// the size of the
//															// value so
//															// keys+values size
//															// is the size of
//															// one row
//											int rows = 100;
//											int frames = 1024;// the size of
//																// neicun
//											int keychaos = 2;// the randomness
//																// of the key
//											int indexSize = 10;// for hash
											int keyorder = (int) left.get(se2);// create
																				// key
																				// by
																				// order
//											BufferManager bm = new BufferManager(
//													frames);
//											FileManager fm = new FileManager(bm);

											File idxFile = new File(
													(String) indexfilename
															.get(se2));
											ManagedFile file;
											TestDataStream ds = new TestDataStream(
													keys, values, rows,
													keychaos, true);
											IndexKeySpec keySpec = new GenericIndexKeySpec(
													ds.getSchema(), keys,
													keyorder);// revised
											Iterator<Datum[]> scan = null;
											try {
												file = fm.open(idxFile);
												IndexFile idx = new ISAMIndex(
														file, keySpec);
												fm.close(idxFile);
												Datum[] to = new Datum[1];
												to[0] = new Datum.Int(
														Integer.parseInt((String) right
																.get(se2)));
												scan = idx.rangeScanTo(to);
											} catch (IOException e) {
												// TODO Auto-generated catch
												// block
												e.printStackTrace();
											}
											ArrayList neworder =new ArrayList (); // this is ordered to produce the index, but 
											while (scan.hasNext()) {
												Datum[] da1 = scan.next();
												neworder.add(da1[1].toString());
											}
											int [] oldorder=new int [neworder.size()];
											for (int old=0;old<neworder.size();old++){
												oldorder[old]=Integer.parseInt(neworder.get(old).toString());
											}
											Arrays.sort(oldorder);
											String []test2 = null;
											for (int old1=0;old1<oldorder.length;old1++){
											test2 = test1.get(oldorder[old1]);// the
											finalresults.add(test2);}

											// for (int se1 = 0; se1 <
											// test1.size(); se1++) {
											// String[] test2 = test1.get(se1);
											// String test3 = test2[(int) left
											// .get(se2)];
											// test3 = test3.replace("-", "");
											//
											// if (!test3.contains(".")) {
											// int test4 =
											// Integer.parseInt(test3);
											// int test5 = Integer
											// .parseInt((String) right
											// .get(se2));
											// if (test4 < test5 || test4 ==
											// test5) {
											// finalresults.add(test2);
											// }
											// } else if (test3.contains(".")) {
											// float test4 = Float
											// .parseFloat(test3);
											// float test5 = Float
											// .parseFloat((String) right
											// .get(se2));
											// if (test4 < test5 || test4 ==
											// test5) {
											// finalresults.add(test2);
											// }
											// }
											// }
										}
									}

									test1 = finalresults;
									finalresults = new ArrayList<String[]>();
								}
							}
							String arrayjoin1[][] = new String[test1.size()][test1
									.get(0).length];// convert the arraylist
													// format
													// into
							// the strring [][] format
//							File tofile = new File("Q6_index_results.txt");
//							FileWriter fw = null;
//							try {
//								fw = new FileWriter(tofile, true);
//							} catch (IOException e1) {
//								// TODO Auto-generated catch block
//								e1.printStackTrace();
//							}
							for (int i11 = 0; i11 < test1.size(); i11++) {
								
								arrayjoin1[i11] = test1.get(i11);
								
								
//								try {
//									
//									
////									fw.write(Integer.toString(1));
////									fw.write(",");
////									fw.write(Integer.toString(2));
////									fw.write("\r\n");
//									for (int o4=0;o4<8;o4++){
//									fw.write(arrayjoin1[i11][o4]);
//									fw.write("\t");
//									}
//									fw.write(arrayjoin1[i11][10]);
//									fw.write("\r\n");
//									
//								} catch (IOException e) {
//									// TODO Auto-generated catch block
//									e.printStackTrace();
//								}

							}
//							try {
//								fw.close();
//							} catch (IOException e) {
//								// TODO Auto-generated catch block
//								e.printStackTrace();
//							}

							int i341 = indexpl.indexOf(in);// this child node
															// can
															// provide
							// data to its father node
							indi[i341] = 1;
							data.set(i341, arrayjoin1);// the data gotten by
														// scanning
							COLNAMES.set(i341, colname);
							// RANGENAMES.set(i341,raname1);
							break;
						} else if (q1s_pushdown.length == 2) {
							byte[] B1 = q1s_pushdown[1].getBytes();
							int b = q1s_pushdown[1].indexOf("(");
							int c1 = q1s_pushdown[1].indexOf(")");

							ArrayList col11 = new ArrayList();

							ArrayList index = new ArrayList();
							for (int in1 = 0; in1 < B1.length; in1++) {
								if (B1[in1] == ',') {
									index.add(in1);
								}
							}
							int a = q1s_pushdown[1].indexOf("[");
							String rangeVar = q1s_pushdown[1].substring(a + 1,
									b);
							table.add(in);
							table.add(rangeVar);

							// range names
							String[] raname = rangeVar.toLowerCase().split("");
							String[] raname1 = new String[1];
							raname1[0] = raname[1];

							int c22 = (int) index.get(0);
							String col1 = q1s_pushdown[1].substring(b + 1, c22);
							table.add(col1);
							col11.add(raname[1]);
							col11.add(col1);
							for (int in1 = 1; in1 < index.size(); in1++) {
								col1 = q1s_pushdown[1].substring(
										(int) index.get(in1 - 1) + 2,
										(int) index.get(in1));
								table.add(col1);
								col11.add(raname[1]);
								col11.add(col1);
							}
							col1 = q1s_pushdown[1].substring(
									(int) index.get(index.size() - 1) + 2, c1);
							table.add(col1);
							col11.add(raname[1]);
							col11.add(col1);

							// column names
							String[] colname = new String[col11.size()];
							for (int i111 = 0; i111 < col11.size(); i111++) {
								colname[i111] = (String) col11.get(i111);
							}

							Schema.TableFromFile table_R123 = tables
									.get(rangeVar);
							String pathadd123 = table_R123.getFile().toString();
							Readtable readr123 = new Readtable();// edu.buffalo.cse.sql.io
							String arraytotal12[][] = readr123.readfile("test/"
									+ pathadd123);

							// consider the select condition in SCAN
							ArrayList left = new ArrayList();
							ArrayList right = new ArrayList();
							ArrayList tord = new ArrayList(); // from table or
																// the
																// real
																// data 1 or 0
							ArrayList calcu = new ArrayList(); // record the
																// 1:"=";2,"<";3,">";4:">=";5"<="
																// if
																// (q1s_pushdown[0].contains("<=")){
							// String [] q4s2 = q1s_pushdown[0].split("<=");
							// int ins = 0;
							// for (int u = 0; u < colname.length; u = u + 2) {
							// if (q4s2[0].contains(colname[u])
							// && q4s2[0].contains(colname[u + 1])) {
							// ins = u / 2;
							// }
							// }
							// left.add(ins);
							//
							// ins = 0;
							// for (int u = 0; u < colname.length; u = u + 2) {
							// if (q4s2[1].contains(colname[u])
							// && q4s2[1].contains(colname[u + 1])) {
							// ins = u / 2;
							// }
							// }
							// if (ins != 0) {
							// right.add(ins);
							// tord.add(1);
							// } else if (ins == 0) {
							// String sdot = q4s2[1].substring(
							// q4s2[1].indexOf("<=") + 2,
							// q4s2[1].length()-1);
							// if (sdot.contains("+")) {
							// int s6 = sdot.indexOf("+");
							// int sle = Integer.parseInt(sdot.substring(
							// 0, s6));
							// int sri = Integer.parseInt(sdot.substring(
							// s6 + 1, sdot.length()));
							//
							// sdot = Integer.toString(sle + sri);
							// }
							// right.add(sdot);
							// tord.add(0);
							// }
							// calcu.add(5);
							// }
							String q4s = q1s_pushdown[0];
							q4s = q4s.replace(" ", "");
							q4s = q4s.replace("SCAN", "");
							q4s = q4s.replace("[", "");
							q4s = q4s.replace("]", "");
							q4s = q4s.replace("(", "");
							q4s = q4s.replace(")", "");
							ArrayList q4s1 = new ArrayList();
							String[] q4s20 = q4s.split("AND");
							for (int s1 = 0; s1 < q4s20.length; s1++) {
								String[] q4s3 = q4s20[s1].split("OR");
								for (int s2 = 0; s2 < q4s3.length; s2++) {
									q4s1.add(q4s3[s2]);
								}
							}
							// transfer the arraylist into string []
							String[] q4s3 = new String[q4s1.size()];
							for (int s3 = 0; s3 < q4s3.length; s3++) {
								q4s3[s3] = (String) q4s1.get(s3);
							}

							// String [] q4s3=new String [1];
							// q4s3[0]=q1s_pushdown[0];
							String[] q4s2;
							for (int s1 = 0; s1 < q4s3.length; s1++) {
								if (q4s3[s1].contains("=")
										&& !q4s3[s1].contains(">")
										&& !q4s3[s1].contains("<")) {
									q4s2 = q4s3[s1].split("=");
									int ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[0].contains(colname[u])
												&& q4s2[0]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									left.add(ins);

									ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[1].contains(colname[u])
												&& q4s2[1]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									if (ins != 0) {
										right.add(ins);
										tord.add(1);
									} else if (ins == 0) {
										int idot = q4s2[1].indexOf("'");
										String sdot = q4s2[1].substring(
												idot + 1, q4s2[1].length() - 1);
										right.add(sdot);
										tord.add(0);
									}
									calcu.add(1);
								} else if (q4s3[s1].contains("<")
										&& !q4s3[s1].contains("<=")) {
									q4s2 = q4s3[s1].split("<");
									int ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[0].contains(colname[u])
												&& q4s2[0]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									left.add(ins);

									ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[1].contains(colname[u])
												&& q4s2[1]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									if (ins != 0) {
										right.add(ins);
										tord.add(1);
									} else if (ins == 0) {
										String sdot = q4s2[1].substring(
												q4s2[1].indexOf("<") + 1,
												q4s2[1].length());
										right.add(sdot);
										tord.add(0);
									}
									calcu.add(2);
								} else if (q4s3[s1].contains("<=")) {
									q4s2 = q4s3[s1].split("<=");
									int ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[0].contains(colname[u])
												&& q4s2[0]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									left.add(ins);

									ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[1].contains(colname[u])
												&& q4s2[1]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									if (ins != 0) {
										right.add(ins);
										tord.add(1);
									} else if (ins == 0) {
										String sdot = q4s2[1].substring(
												q4s2[1].indexOf("<=") + 1,
												q4s2[1].length());
										if (sdot.contains("+")) {
											int s6 = sdot.indexOf("+");
											int sle = Integer.parseInt(sdot
													.substring(0, s6));
											int sri = Integer.parseInt(sdot
													.substring(s6 + 1,
															sdot.length()));

											sdot = Integer.toString(sle + sri);
										}
										right.add(sdot);
										tord.add(0);
									}
									calcu.add(5);
								} else if (q4s3[s1].contains(">")
										&& !q4s3[s1].contains(">=")) {
									q4s2 = q4s3[s1].split(">");
									int ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[0].contains(colname[u])
												&& q4s2[0]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									left.add(ins);

									ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[1].contains(colname[u])
												&& q4s2[1]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									if (ins != 0) {
										right.add(ins);
										tord.add(1);
									} else if (ins == 0) {
										String sdot = q4s2[1].substring(
												q4s2[1].indexOf(">") + 1,
												q4s2[1].length());
										right.add(sdot);
										tord.add(0);
									}
									calcu.add(3);
								} else if (q4s3[s1].contains(">=")) {
									q4s2 = q4s3[s1].split(">=");
									int ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[0].contains(colname[u])
												&& q4s2[0]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									left.add(ins);

									ins = 0;
									for (int u = 0; u < colname.length; u = u + 2) {
										if (q4s2[1].contains(colname[u])
												&& q4s2[1]
														.contains(colname[u + 1])) {
											ins = u / 2;
										}
									}
									if (ins != 0) {
										right.add(ins);
										tord.add(1);
									} else if (ins == 0) {
										String sdot = q4s2[1].substring(
												q4s2[1].indexOf(">=") + 1,
												q4s2[1].length());
										right.add(sdot);
										tord.add(0);
									}
									calcu.add(4);
								}
							}
							ArrayList<String[]> finalresults = new ArrayList<String[]>();
							ArrayList<String[]> test1 = new ArrayList<String[]>();
							for (int se3 = 0; se3 < arraytotal12.length; se3++) {
								test1.add(arraytotal12[se3]);
							}
							// String [][] test1=arraySELECT;
							for (int se2 = 0; se2 < calcu.size(); se2++) {
								if ((int) calcu.get(se2) == 1) {
									if ((int) tord.get(se2) == 0) {
										for (int se1 = 0; se1 < test1.size(); se1++) {
											String[] test2 = test1.get(se1);
											if (test2[(int) left.get(se2)]
													.equals((String) right
															.get(se2))) {
												finalresults.add(test2);
											}
										}
									} else if ((int) tord.get(se2) == 1) {
										for (int se1 = 0; se1 < test1.size(); se1++) {
											String[] test2 = test1.get(se1);
											if (test2[(int) left.get(se2)]
													.equals(test2[(int) right
															.get(se2)])) {
												finalresults.add(test2);
											}
										}
									}
								} else if ((int) calcu.get(se2) == 2) {
									if ((int) tord.get(se2) == 0) {
										for (int se1 = 0; se1 < test1.size(); se1++) {
											String[] test2 = test1.get(se1);
											String test3 = test2[(int) left
													.get(se2)];
											test3 = test3.replace("-", "");
											if (!test3.contains(".")) {
												int test4 = Integer
														.parseInt(test3);
												int test5 = Integer
														.parseInt((String) right
																.get(se2));
												if (test4 < test5) {
													finalresults.add(test2);
												}
											} else if (test3.contains(".")) {
												float test4 = Float
														.parseFloat(test3);
												float test5 = Float
														.parseFloat((String) right
																.get(se2));
												if (test4 < test5) {
													finalresults.add(test2);
												}
											}

										}
									}
								} else if ((int) calcu.get(se2) == 3) {
									if ((int) tord.get(se2) == 0) {
										for (int se1 = 0; se1 < test1.size(); se1++) {
											String[] test2 = test1.get(se1);
											String test3 = test2[(int) left
													.get(se2)];
											test3 = test3.replace("-", "");
											if (!test3.contains(".")) {
												int test4 = Integer
														.parseInt(test3);
												int test5 = Integer
														.parseInt((String) right
																.get(se2));
												if (test4 > test5) {
													finalresults.add(test2);
												}
											} else if (test3.contains(".")) {
												float test4 = Float
														.parseFloat(test3);
												float test5 = Float
														.parseFloat((String) right
																.get(se2));
												if (test4 > test5) {
													finalresults.add(test2);
												}
											}

										}
									}
								} else if ((int) calcu.get(se2) == 4) {
									if ((int) tord.get(se2) == 0) {
										for (int se1 = 0; se1 < test1.size(); se1++) {
											String[] test2 = test1.get(se1);
											String test3 = test2[(int) left
													.get(se2)];
											test3 = test3.replace("-", "");

											if (!test3.contains(".")) {
												int test4 = Integer
														.parseInt(test3);
												int test5 = Integer
														.parseInt((String) right
																.get(se2));
												if (test4 > test5
														|| test4 == test5) {
													finalresults.add(test2);
												}
											} else if (test3.contains(".")) {
												float test4 = Float
														.parseFloat(test3);
												float test5 = Float
														.parseFloat((String) right
																.get(se2));
												if (test4 > test5
														|| test4 == test5) {
													finalresults.add(test2);
												}
											}
										}
									}
								} else if ((int) calcu.get(se2) == 5) {
									if ((int) tord.get(se2) == 0) {
										for (int se1 = 0; se1 < test1.size(); se1++) {
											String[] test2 = test1.get(se1);
											String test3 = test2[(int) left
													.get(se2)];
											test3 = test3.replace("-", "");

											if (!test3.contains(".")) {
												int test4 = Integer
														.parseInt(test3);
												int test5 = Integer
														.parseInt((String) right
																.get(se2));
												if (test4 < test5
														|| test4 == test5) {
													finalresults.add(test2);
												}
											} else if (test3.contains(".")) {
												float test4 = Float
														.parseFloat(test3);
												float test5 = Float
														.parseFloat((String) right
																.get(se2));
												if (test4 < test5
														|| test4 == test5) {
													finalresults.add(test2);
												}
											}
										}
									}
								}

								test1 = finalresults;
								finalresults = new ArrayList<String[]>();
							}
							String arrayjoin1[][] = new String[test1.size()][test1
									.get(0).length];// convert the arraylist
													// format
													// into
													// the strring [][] format
							for (int i11 = 0; i11 < test1.size(); i11++) {
								arrayjoin1[i11] = test1.get(i11);
							}

							int i341 = indexpl.indexOf(in);// this child node
															// can
															// provide
															// data to its
															// father
															// node
							indi[i341] = 1;
							data.set(i341, arrayjoin1);// the data gotten by
														// scanning
							COLNAMES.set(i341, colname);
							// RANGENAMES.set(i341,raname1);
							break;
						}
					} else {
						byte[] B1 = q1s.getBytes();
						int b = q1s.indexOf("(");
						int c1 = q1s.indexOf(")");

						ArrayList col11 = new ArrayList();

						ArrayList index = new ArrayList();
						for (int in1 = 0; in1 < B1.length; in1++) {
							if (B1[in1] == ',') {
								index.add(in1);
							}
						}
						int a = q1s.indexOf("[");
						String rangeVar = q1s.substring(a + 1, b);
						table.add(in);
						table.add(rangeVar);

						// range names
						String[] raname = rangeVar.toLowerCase().split("");
						String[] raname1 = new String[1];
						raname1[0] = raname[1];

						int c22 = (int) index.get(0);
						String col1 = q1s.substring(b + 1, c22);
						table.add(col1);
						col11.add(raname[1]);
						col11.add(col1);
						for (int in1 = 1; in1 < index.size(); in1++) {
							col1 = q1s.substring((int) index.get(in1 - 1) + 2,
									(int) index.get(in1));
							table.add(col1);
							col11.add(raname[1]);
							col11.add(col1);
						}
						col1 = q1s.substring(
								(int) index.get(index.size() - 1) + 2, c1);
						table.add(col1);
						col11.add(raname[1]);
						col11.add(col1);

						// column names
						String[] colname = new String[col11.size()];
						for (int i111 = 0; i111 < col11.size(); i111++) {
							colname[i111] = (String) col11.get(i111);
						}

						Schema.TableFromFile table_R123 = tables.get(rangeVar);
						String pathadd123 = table_R123.getFile().toString();
						Readtable readr123 = new Readtable();// edu.buffalo.cse.sql.io
						String arraytotal12[][] = new String[1][1];
						if (pathadd123.contains("test")) {
							arraytotal12 = readr123.readfile(pathadd123);
						}

						else if (!pathadd123.contains("test")) {
							arraytotal12 = readr123.readfile("test/"
									+ pathadd123);
						}

						int i341 = indexpl.indexOf(in);// this child node can
														// provide
						// data to its father node
						indi[i341] = 1;
						data.set(i341, arraytotal12);// the data gotten by
														// scanning
						COLNAMES.set(i341, colname);
						// RANGENAMES.set(i341,raname1);
						break;
					}
				case AGGREGATE:
					String q2s = q1.detailString();

					q2s = q2s.replace(" ", "");
					String[] q31s = q2s.split(":");
					ArrayList q41s = new ArrayList();// all the queries it needs
					for (int i4s = 0; i4s < q31s.length; i4s++) {
						if (q31s[i4s].contains(",")) {
							String[] q5s = q31s[i4s].split(",");
							q41s.add(q5s[0]);
						} else if (q31s[i4s].contains("]")) {
							String[] q5s = q31s[i4s].split("]");
							q41s.add(q5s[0]);
						}

					}

					int i1 = 0;
					int i2 = 0;
					int index1 = -100;
					ArrayList<Datum[]> ret = new ArrayList<Datum[]>();

					int cal = 0; // calculation number in AGGREGATE
					String arraytotal[][] = new String[0][0];
					int i66 = indexpl.indexOf(in * 10 + 1);
					arraytotal = (String[][]) data.get(i66);

					String[] colnames2 = new String[0];
					colnames2 = (String[]) COLNAMES.get(i66);

					// find the "group by" key colnames
					ArrayList groupBY = new ArrayList();
					for (int u = 0; u < q41s.size(); u++) {
						String s1 = (String) q41s.get(u);
						if (!s1.contains("SUM") && !s1.contains("AVG")
								&& !s1.contains("COUNT")) {
							groupBY.add(s1);
						}
					}
					// no groupBY columns
					if (groupBY.isEmpty()) {

						int[] flag = new int[arraytotal.length];
						String[] s1Groupby = new String[q41s.size()];
						ArrayList<String[]> resultGroupby = new ArrayList<String[]>(); // the
						// final
						// result
						int length = arraytotal.length;
						for (int u3 = 0; u3 < q41s.size(); u3++) {
							String s1 = (String) q41s.get(u3);
							if (s1.contains("SUM")) {
								int a1 = s1.indexOf("M");
								int b1 = s1.length() - 1;
								i1 = 0;
								i2 = 0;
								index1 = -100;
								String parString = s1.substring(a1 + 2, b1);
								if (parString.contains("*")) {
									BigDecimal sum = new BigDecimal(0);
									for (int y2 = 0; y2 < arraytotal.length; y2++) {
										String[] splitStr = parString
												.split("[*]");
										float[] floatResult = new float[splitStr.length];
										for (int y1 = 0; y1 < splitStr.length; y1++) {
											if (splitStr[y1].contains("-")) {
												splitStr[y1] = splitStr[y1]
														.replace("(", "");
												splitStr[y1] = splitStr[y1]
														.replace(")", "");
												String[] splitStr1 = splitStr[y1]
														.split("[-]");
												float forward = 0;
												float bacward = 0;

												int index_for = 0;
												for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
													if (splitStr1[0]
															.contains(colnames2[u5])
															&& splitStr1[0]
																	.contains(colnames2[u5 + 1])) {
														index_for = u5 / 2;
													}
												}
												if (index_for == 0) {
													String s11 = splitStr1[0];
													float f1 = Float
															.parseFloat(splitStr1[0]);
													forward = Float
															.parseFloat(splitStr1[0]);
												}
												int index_bac = 0;
												for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
													if (splitStr1[1]
															.contains(colnames2[u5])
															&& splitStr1[1]
																	.contains(colnames2[u5 + 1])) {
														index_bac = u5 / 2;
													}
												}
												if (index_bac != 0) {
													bacward = Float
															.parseFloat(arraytotal[y2][index_bac]);
												}
												floatResult[y1] = forward
														- bacward;
											} else if (splitStr[y1]
													.contains("+")) {
												splitStr[y1] = splitStr[y1]
														.replace("(", "");
												splitStr[y1] = splitStr[y1]
														.replace(")", "");
												String[] splitStr1 = splitStr[y1]
														.split("[+]");
												float forward = 0;
												float bacward = 0;

												int index_for = 0;
												for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
													if (splitStr1[0]
															.contains(colnames2[u5])
															&& splitStr1[0]
																	.contains(colnames2[u5 + 1])) {
														index_for = u5 / 2;
													}
												}
												if (index_for == 0) {
													forward = Float
															.parseFloat(splitStr1[0]);
												}
												int index_bac = 0;
												for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
													if (splitStr1[1]
															.contains(colnames2[u5])
															&& splitStr1[1]
																	.contains(colnames2[u5 + 1])) {
														index_bac = u5 / 2;
													}
												}
												if (index_bac != 0) {
													bacward = Float
															.parseFloat(arraytotal[y2][index_bac]);
												}
												floatResult[y1] = forward
														+ bacward;
											} else {
												int index_1 = 0;
												for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
													if (splitStr[y1]
															.contains(colnames2[u5])
															&& splitStr[y1]
																	.contains(colnames2[u5 + 1])) {
														index_1 = u5 / 2;
													}
												}
												floatResult[y1] = Float
														.parseFloat(arraytotal[y2][index_1]);
											}
										}
										float sum1 = 1;
										for (int y3 = 0; y3 < floatResult.length; y3++) {
											sum1 = sum1 * floatResult[y3];
										}
										float sum2 = sum.floatValue() + sum1;
										sum=new BigDecimal(String.valueOf(sum2));
									}
									
									s1Groupby[u3] = sum.toString();
									
								}
							}
							resultGroupby.add(s1Groupby);
						}
						for (int y3 = 0; y3 < resultGroupby.size(); y3++) {
							Datum[] ret13 = new Datum[q41s.size()];
							String[] s11 = resultGroupby.get(y3);
							for (int y4 = 0; y4 < ret13.length; y4++) {
								ret13[y4] = new Datum.Str(s11[y4]);
							}
							ret.add(ret13);
						}

					} else {
						// find the index of the "group by" colnames in the data
						// of
						// next
						// node
						ArrayList groupIndex = new ArrayList();
						for (int u1 = 0; u1 < groupBY.size(); u1++) {
							String s1 = (String) groupBY.get(u1);
							String[] s11 = s1.split("[.]");
							for (int u = 0; u < colnames2.length; u = u + 2) {
								if (s11[0].equals((String) colnames2[u])
										&& s11[1]
												.equals((String) colnames2[u + 1])) {
									groupIndex.add(u / 2);
								}
							}
						}

						int[] flag = new int[arraytotal.length];
						ArrayList<String[]> resultGroupby = new ArrayList<String[]>(); // the
						// final
						// result

						for (int u = 0; u < arraytotal.length; u++) {
							ArrayList<String[]> arrayGroupby = new ArrayList<String[]>();
							int lengthGroupby = 0;
							if (flag[u] == 0) {// group the data
								arrayGroupby.add(arraytotal[u]);
								lengthGroupby++;
								for (int u1 = u + 1; u1 < arraytotal.length; u1++) {
									int FLAG = 0;
									for (int u2 = 0; u2 < groupIndex.size(); u2++) {// group
										// index
										// must
										// be
										// the
										// same
										String s1 = arraytotal[u1][(int) groupIndex
												.get(u2)];
										String s2 = arraytotal[u][(int) groupIndex
												.get(u2)];
										if (!s1.equals(s2)) {
											FLAG = 1;
										}
									}
									if (FLAG == 0) {
										arrayGroupby.add(arraytotal[u1]);
										lengthGroupby++;
										flag[u1] = 1; // has been checked
									}
								}
								flag[u] = 1;
								// the arrayGroupby is known, then we can
								// calculate
								// the
								// corresponding results

								String[][] stringGroupby = new String[lengthGroupby][arrayGroupby
										.get(0).length];
								for (int u4 = 0; u4 < lengthGroupby; u4++) {
									stringGroupby[u4] = arrayGroupby.get(u4);
								}
								String[] s1Groupby = new String[q41s.size()];// to
								// save
								// the
								// calculation
								// result
								// for
								// each
								// group
								int y = 0;
								for (int u3 = 0; u3 < q41s.size(); u3++) {
									String s1 = (String) q41s.get(u3);
									if (!s1.contains("SUM")
											&& !s1.contains("AVG")
											&& !s1.contains("COUNT")) {
										s1Groupby[u3] = stringGroupby[0][(int) groupIndex
												.get(y)];// save the group by
															// key
										y = y + 1;
									} else if (s1.contains("SUM")) {
										int a1 = s1.indexOf("M");
										int b1 = s1.length() - 1;
										i1 = 0;
										i2 = 0;
										index1 = -100;
										String parString = s1.substring(a1 + 2,
												b1);
										if (parString.contains("*")) {
											float sum = 0;
											for (int y2 = 0; y2 < stringGroupby.length; y2++) {
												String[] splitStr = parString
														.split("[*]");
												float[] floatResult = new float[splitStr.length];
												for (int y1 = 0; y1 < splitStr.length; y1++) {
													if (splitStr[y1]
															.contains("-")) {
														splitStr[y1] = splitStr[y1]
																.replace("(",
																		"");
														splitStr[y1] = splitStr[y1]
																.replace(")",
																		"");
														String[] splitStr1 = splitStr[y1]
																.split("[-]");
														float forward = 0;
														float bacward = 0;

														int index_for = 0;
														for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
															if (splitStr1[0]
																	.contains(colnames2[u5])
																	&& splitStr1[0]
																			.contains(colnames2[u5 + 1])) {
																index_for = u5 / 2;
															}
														}
														if (index_for == 0) {
															String s11 = splitStr1[0];
															float f1 = Float
																	.parseFloat(splitStr1[0]);
															forward = Float
																	.parseFloat(splitStr1[0]);
														}
														int index_bac = 0;
														for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
															if (splitStr1[1]
																	.contains(colnames2[u5])
																	&& splitStr1[1]
																			.contains(colnames2[u5 + 1])) {
																index_bac = u5 / 2;
															}
														}
														if (index_bac != 0) {
															bacward = Float
																	.parseFloat(stringGroupby[y2][index_bac]);
														}
														floatResult[y1] = forward
																- bacward;
													} else if (splitStr[y1]
															.contains("+")) {
														splitStr[y1] = splitStr[y1]
																.replace("(",
																		"");
														splitStr[y1] = splitStr[y1]
																.replace(")",
																		"");
														String[] splitStr1 = splitStr[y1]
																.split("[+]");
														float forward = 0;
														float bacward = 0;

														int index_for = 0;
														for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
															if (splitStr1[0]
																	.contains(colnames2[u5])
																	&& splitStr1[0]
																			.contains(colnames2[u5 + 1])) {
																index_for = u5 / 2;
															}
														}
														if (index_for == 0) {
															forward = Float
																	.parseFloat(splitStr1[0]);
														}
														int index_bac = 0;
														for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
															if (splitStr1[1]
																	.contains(colnames2[u5])
																	&& splitStr1[1]
																			.contains(colnames2[u5 + 1])) {
																index_bac = u5 / 2;
															}
														}
														if (index_bac != 0) {
															bacward = Float
																	.parseFloat(stringGroupby[y2][index_bac]);
														}
														floatResult[y1] = forward
																+ bacward;
													} else {
														int index_1 = 0;
														for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
															if (splitStr[y1]
																	.contains(colnames2[u5])
																	&& splitStr[y1]
																			.contains(colnames2[u5 + 1])) {
																index_1 = u5 / 2;
															}
														}
														floatResult[y1] = Float
																.parseFloat(stringGroupby[y2][index_1]);
													}
												}
												float sum1 = 1;
												for (int y3 = 0; y3 < floatResult.length; y3++) {
													sum1 = sum1
															* floatResult[y3];
												}
												sum = sum + sum1;
											}
											s1Groupby[u3] = Float.toString(sum);

										} else {
											// find the index of the "group by"
											// colnames
											// in the data of next node
											ArrayList groupIndex1 = new ArrayList();
											for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
												if (s1.contains(colnames2[u5])
														&& s1.contains(colnames2[u5 + 1])) {
													groupIndex1.add(u5 / 2);
												}
											}
											int sum = 0;
											float sumf = 0;
											for (int u7 = 0; u7 < stringGroupby.length; u7++) {
												String str1 = stringGroupby[u7][(int) groupIndex1
														.get(0)];
												if (str1.contains(".")) {
													float sum1 = Float
															.parseFloat(str1);
													sumf = sumf + sum1;
												} else if (!str1.contains(".")) {
													int sum1 = Integer
															.parseInt(str1);
													sum = sum + sum1;
												}

											}
											if (sum == 0) {
												s1Groupby[u3] = Float
														.toString(sumf);
											} else if (sum != 0) {
												s1Groupby[u3] = Integer
														.toString(sum);
											}

										}
									} else if (s1.contains("AVG")) {
										int a1 = s1.indexOf("G(");
										int b1 = 0;
										for (int i41 = a1 + 1; i41 < s1
												.length(); i41++) {
											if (s1.substring(i41, i41 + 1)
													.equals(")")) {
												b1 = i41;
												break;
											}
										}
										i1 = 0;
										i2 = 0;
										index1 = -100;
										String parString = s1.substring(a1 + 2,
												b1);

										ArrayList groupIndex1 = new ArrayList();
										for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
											if (s1.contains(colnames2[u5])
													&& s1.contains(colnames2[u5 + 1])) {
												groupIndex1.add(u5 / 2);
											}
										}
										int sum = 0;
										float sumf = 0;
										for (int u7 = 0; u7 < stringGroupby.length; u7++) {
											String str1 = stringGroupby[u7][(int) groupIndex1
													.get(0)];
											if (str1.contains(".")) {
												float sum1 = Float
														.parseFloat(str1);
												sumf = sumf + sum1;
											} else if (!str1.contains(".")) {
												int sum1 = Integer
														.parseInt(str1);
												sum = sum + sum1;
											}

										}

										if (sum == 0) {
											s1Groupby[u3] = Float.toString(sumf
													/ stringGroupby.length);
										} else if (sum != 0) {
											float sum2 = sum
													/ stringGroupby.length;
											s1Groupby[u3] = Float
													.toString(sum2);
										}

									} else if (s1.contains("COUNT")) {
										s1Groupby[u3] = Integer
												.toString(lengthGroupby);
									}
								}
								resultGroupby.add(s1Groupby);
							}

						}
						for (int y3 = 0; y3 < resultGroupby.size(); y3++) {
							Datum[] ret13 = new Datum[q41s.size()];
							String[] s11 = resultGroupby.get(y3);
							for (int y4 = 0; y4 < ret13.length; y4++) {
								ret13[y4] = new Datum.Str(s11[y4]);
							}
							ret.add(ret13);
						}
					}
					List<Var> qv = q.getSchemaVars();
					TableBuilder output = new TableBuilder();
					output.newRow();
					for (int icao = 0; icao < qv.size(); icao++) {
						output.newCell(qv.get(icao).toString());
					}
					// System.out.println(output);
					output.addDividerLine();
					List<Datum[]> computedResults1 = ret;
					int queryID = 0;
					for (; queryID < computedResults1.size(); queryID++) {
						Datum[] row = computedResults1.get(queryID);
						output.newRow();
						for (Datum d : row) {
							output.newCell(d.toString());
						}
					}
					System.out.println(output);
					return ret;
					// break;
				case PROJECT:

					break;
				case SELECT:

					// int [] colIndex=new int [table.size()];
					String q4s = q1.detailString();
					// System.out.println(q4s);
					q4s = q4s.trim();
					char[] c = q4s.toCharArray();

					String arraySELECT[][] = new String[0][0];
					int iSELECT = indexpl.indexOf(in * 10 + 1);
					arraySELECT = (String[][]) data.get(iSELECT);

					String[] cnSELECT = new String[0];
					cnSELECT = (String[]) COLNAMES.get(iSELECT);
					if (q4s.contains("AND") && q4s.contains("OR")) {
						// seperate q4s by "AND" "OR"
						q4s = q4s.replace(" ", "");
						q4s = q4s.replace("SELECT", "");
						q4s = q4s.replace("[", "");
						q4s = q4s.replace("]", "");
						q4s = q4s.replace("(", "");
						q4s = q4s.replace(")", "");
						ArrayList q4s1 = new ArrayList();
						String[] q4s2 = q4s.split("AND");
						for (int s1 = 0; s1 < q4s2.length; s1++) {
							String[] q4s3 = q4s2[s1].split("OR");
							for (int s2 = 0; s2 < q4s3.length; s2++) {
								q4s1.add(q4s3[s2]);
							}
						}
						// transfer the arraylist into string []
						String[] q4s3 = new String[q4s1.size()];
						for (int s3 = 0; s3 < q4s3.length; s3++) {
							q4s3[s3] = (String) q4s1.get(s3);
						}

						// find the relationships between the left and right in
						// the
						// conditions
						ArrayList left = new ArrayList();
						ArrayList right = new ArrayList();
						ArrayList tord = new ArrayList(); // from table or the
															// real
						// data 1 or 0
						ArrayList calcu = new ArrayList(); // record the
						// 1:"=";2,"<";3,">";4:">=";5"<="
						for (int s1 = 0; s1 < q4s3.length; s1++) {
							if (q4s3[s1].contains("=")
									&& !q4s3[s1].contains(">")
									&& !q4s3[s1].contains("<")) {
								q4s2 = q4s3[s1].split("=");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									int idot = q4s2[1].indexOf("'");
									String sdot = q4s2[1].substring(idot + 1,
											q4s2[1].length() - 1);
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(1);
							} else if (q4s3[s1].contains("<")
									&& !q4s3[s1].contains("<=")) {
								q4s2 = q4s3[s1].split("<");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf("<") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(2);
							} else if (q4s3[s1].contains("<=")) {
								q4s2 = q4s3[s1].split("<=");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf("<=") + 1,
											q4s2[1].length());
									if (sdot.contains("+")) {
										int s6 = sdot.indexOf("+");
										int sle = Integer.parseInt(sdot
												.substring(0, s6));
										int sri = Integer.parseInt(sdot
												.substring(s6 + 1,
														sdot.length()));

										sdot = Integer.toString(sle + sri);
									}
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(5);
							} else if (q4s3[s1].contains(">")
									&& !q4s3[s1].contains(">=")) {
								q4s2 = q4s3[s1].split(">");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf(">") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(3);
							} else if (q4s3[s1].contains(">=")) {
								q4s2 = q4s3[s1].split(">=");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf(">=") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(4);
							}
						}
						ArrayList<String[]> FINAL = new ArrayList<String[]>();// this
						// records
						// the
						// final
						// results
						// decide if it includs very long "OR"
						ArrayList indexOR = new ArrayList();

						for (int s5 = 0; s5 < left.size(); s5++) {
							if (left.get(s5) == left.get(0) && s5 > 1) {
								indexOR.add(s5);
							}
						}
						if (indexOR.size() == 1) {
						}// only one whole search query
						else if (indexOR.size() > 1) {// several queries because
														// of
							// "OR"
							ArrayList<String[]> finalresults = new ArrayList<String[]>();
							ArrayList<String[]> test1 = new ArrayList<String[]>();
							for (int se3 = 0; se3 < arraySELECT.length; se3++) {
								test1.add(arraySELECT[se3]);
							}
							// String [][] test1=arraySELECT;
							int se2 = 0;
							while (se2 < calcu.size()) {

								if (indexOR.contains(se2)) {// restart because
															// of
									// "OR"
									for (int se3 = 0; se3 < test1.size(); se3++) {
										FINAL.add(test1.get(se3));
									}
									finalresults = new ArrayList<String[]>();
									test1 = new ArrayList<String[]>();
									for (int se3 = 0; se3 < arraySELECT.length; se3++) {
										test1.add(arraySELECT[se3]);
									}
								}

								int gap = 1;
								int gap0 = se2 + 1;
								while (gap0 < left.size()
										&& left.get(gap0) == left.get(se2)
										&& calcu.get(gap0) == calcu.get(se2)) {
									gap++;
									gap0++;
								}
								// several connecutive "OR"
								if (gap > 1) {
									int se8 = 0;
									while (se8 < gap) {
										if ((int) calcu.get(se2 + se8) == 1) {
											if ((int) tord.get(se2 + se8) == 0) {
												for (int se1 = 0; se1 < test1
														.size(); se1++) {
													String[] test2 = test1
															.get(se1);
													String test3 = test2[(int) left
															.get(se2 + se8)];
													test3 = test3.replace(" ",
															"");
													if (test3
															.equals((String) right
																	.get(se2
																			+ se8))) {
														finalresults.add(test2);
													}
												}
											} else if ((int) tord
													.get(se2 + se8) == 1) {
												for (int se1 = 0; se1 < test1
														.size(); se1++) {
													String[] test2 = test1
															.get(se1);
													if (test2[(int) left
															.get(se2 + se8)]
															.equals(test2[(int) right
																	.get(se2
																			+ se8)])) {
														finalresults.add(test2);
													}
												}
											}
										}
										se8++;
									}

								} else {
									if ((int) calcu.get(se2) == 1) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace(" ", "");
												if (test3.equals((String) right
														.get(se2))) {
													finalresults.add(test2);
												}
											}
										} else if ((int) tord.get(se2) == 1) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												if (test2[(int) left.get(se2)]
														.equals(test2[(int) right
																.get(se2)])) {
													finalresults.add(test2);
												}
											}
										}
									} else if ((int) calcu.get(se2) == 2) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");
												if (!test3.contains(".")) {
													int test4 = Integer
															.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 < test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 < test5) {
														finalresults.add(test2);
													}
												}

											}
										}
									} else if ((int) calcu.get(se2) == 3) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");
												if (!test3.contains(".")) {
													int test4 = Integer
															.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 > test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 > test5) {
														finalresults.add(test2);
													}
												}

											}
										}
									} else if ((int) calcu.get(se2) == 4) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");

												if (!test3.contains(".")) {
													int test4 = Integer
															.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 > test5
															|| test4 == test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 > test5
															|| test4 == test5) {
														finalresults.add(test2);
													}
												}
											}
										}
									} else if ((int) calcu.get(se2) == 5) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");

												if (!test3.contains(".")) {
													int test4 = Integer
															.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 < test5
															|| test4 == test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 < test5
															|| test4 == test5) {
														finalresults.add(test2);
													}
												}
											}
										}
									}

								}
								se2 = se2 + gap;
								test1 = finalresults;
								finalresults = new ArrayList<String[]>();
							}
							String arrayjoin1[][] = new String[FINAL.size()][FINAL
									.get(0).length];// convert the arraylist
													// format
							// into
							// the strring [][] format
							for (int i11 = 0; i11 < FINAL.size(); i11++) {
								arrayjoin1[i11] = FINAL.get(i11);
							}

							int i51 = indexpl.indexOf(in);
							int i511 = indexpl.indexOf(in * 10 + 1);
							indi[i51] = 1;
							data.set(i51, arrayjoin1);
							COLNAMES.set(i51, COLNAMES.get(i511));
							break;
						}

					} else if (q4s.contains("AND") && !q4s.contains("OR")) {
						q4s = q4s.replace(" ", "");
						q4s = q4s.replace("SELECT", "");
						q4s = q4s.replace("[", "");
						q4s = q4s.replace("]", "");
						q4s = q4s.replace("(", "");
						q4s = q4s.replace(")", "");
						String[] q4s1 = q4s.split("AND");
						ArrayList left = new ArrayList();
						ArrayList right = new ArrayList();
						ArrayList tord = new ArrayList(); // from table or the
															// real
						// data 1 or 0
						ArrayList calcu = new ArrayList(); // record the
						// 1:"=";2,"<";3,">";4:">="
						for (int s1 = 0; s1 < q4s1.length; s1++) {
							if (q4s1[s1].contains("=")
									&& !q4s1[s1].contains(">")
									&& !q4s1[s1].contains("<")) {
								String[] q4s2 = q4s1[s1].split("=");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									int idot = q4s2[1].indexOf("'");
									String sdot = q4s2[1].substring(idot + 1,
											q4s2[1].length() - 1);
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(1);
							} else if (q4s1[s1].contains("<")) {
								String[] q4s2 = q4s1[s1].split("<");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf("<") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(2);
							} else if (q4s1[s1].contains(">")
									&& !q4s1[s1].contains(">=")) {
								String[] q4s2 = q4s1[s1].split(">");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf(">") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(3);
							} else if (q4s1[s1].contains(">=")) {
								String[] q4s2 = q4s1[s1].split(">=");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf(">=") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(4);
							}
						}
						// after the conditions are all detected
						ArrayList<String[]> finalresults = new ArrayList<String[]>();
						ArrayList<String[]> test1 = new ArrayList<String[]>();
						for (int se3 = 0; se3 < arraySELECT.length; se3++) {
							test1.add(arraySELECT[se3]);
						}
						// String [][] test1=arraySELECT;
						for (int se2 = 0; se2 < calcu.size(); se2++) {
							if ((int) calcu.get(se2) == 1) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										if (test2[(int) left.get(se2)]
												.equals((String) right.get(se2))) {
											finalresults.add(test2);
										}
									}
								} else if ((int) tord.get(se2) == 1) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										if (test2[(int) left.get(se2)]
												.equals(test2[(int) right
														.get(se2)])) {
											finalresults.add(test2);
										}
									}
								}
							} else if ((int) calcu.get(se2) == 2) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										String test3 = test2[(int) left
												.get(se2)];
										test3 = test3.replace("-", "");
										if (!test3.contains(".")) {
											int test4 = Integer.parseInt(test3);
											int test5 = Integer
													.parseInt((String) right
															.get(se2));
											if (test4 < test5) {
												finalresults.add(test2);
											}
										} else if (test3.contains(".")) {
											float test4 = Float
													.parseFloat(test3);
											float test5 = Float
													.parseFloat((String) right
															.get(se2));
											if (test4 < test5) {
												finalresults.add(test2);
											}
										}

									}
								}
							} else if ((int) calcu.get(se2) == 3) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										String test3 = test2[(int) left
												.get(se2)];
										test3 = test3.replace("-", "");
										if (!test3.contains(".")) {
											int test4 = Integer.parseInt(test3);
											int test5 = Integer
													.parseInt((String) right
															.get(se2));
											if (test4 > test5) {
												finalresults.add(test2);
											}
										} else if (test3.contains(".")) {
											float test4 = Float
													.parseFloat(test3);
											float test5 = Float
													.parseFloat((String) right
															.get(se2));
											if (test4 > test5) {
												finalresults.add(test2);
											}
										}

									}
								}
							} else if ((int) calcu.get(se2) == 4) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										String test3 = test2[(int) left
												.get(se2)];
										test3 = test3.replace("-", "");

										if (!test3.contains(".")) {
											int test4 = Integer.parseInt(test3);
											int test5 = Integer
													.parseInt((String) right
															.get(se2));
											if (test4 > test5 || test4 == test5) {
												finalresults.add(test2);
											}
										} else if (test3.contains(".")) {
											float test4 = Float
													.parseFloat(test3);
											float test5 = Float
													.parseFloat((String) right
															.get(se2));
											if (test4 > test5 || test4 == test5) {
												finalresults.add(test2);
											}
										}
									}
								}
							}
							test1 = finalresults;
							finalresults = new ArrayList<String[]>();
						}
						String arrayjoin1[][] = new String[test1.size()][test1
								.get(0).length];// convert the arraylist format
												// into
						// the strring [][] format
						for (int i11 = 0; i11 < test1.size(); i11++) {
							arrayjoin1[i11] = test1.get(i11);
						}

						int i51 = indexpl.indexOf(in);
						int i511 = indexpl.indexOf(in * 10 + 1);
						indi[i51] = 1;
						data.set(i51, arrayjoin1);
						COLNAMES.set(i51, COLNAMES.get(i511));
						break;

					} else {// 04/12/2013
						ArrayList<String> colnames1 = new ArrayList();
						ArrayList<String> ragnames1 = new ArrayList();
						int icol1 = 0;
						// System.out.println(sp[0]);
						// ArrayList dot=new ArrayList ();
						int leftdot = 0;
						int rightdot = 0;
						for (int i11 = 0; i11 < c.length; i11++) { // got the
																	// index
							// of '.'
							if (c[i11] == '.') {
								if (leftdot == 0) {
									leftdot = i11;
								} else if (rightdot == 0) {
									rightdot = i11;
								}
							}
						}

						String leftRgename = String.valueOf(c[leftdot - 1]);
						String leftColname = String.valueOf(c[leftdot + 1]);
						String rigRgename = "";
						String rigColname = "";
						if (rightdot != 0) {
							rigRgename = String.valueOf(c[rightdot - 1]);
							rigColname = String.valueOf(c[rightdot + 1]);
						} else if (rightdot == 0) {
							if (q4s.contains("<=")) {
								leftColname = q4s.substring(leftdot + 1,
										q4s.indexOf("<=") - 1);
								rigColname = q4s
										.substring(q4s.indexOf("<=") + 2,
												q4s.indexOf(")"));
							}
						}

						int l = 0;
						int r = 0;
						if (leftdot != 0 && rightdot == 0) {
							i2 = table.indexOf(leftColname);
							int i6 = indexpl.indexOf(in * 10 + 1);
							arraytotal = (String[][]) data.get(i6);
							ArrayList<String[]> arraySelect = new ArrayList<String[]>();
							int i12 = 0;
							if (q4s.contains("<=")) {
								for (int i11 = 0; i11 < arraytotal.length; i11++) {
									String s1 = arraytotal[i11][i2 - 2]
											.replace("-", "");
									String se = s1;
									int se1 = Integer.parseInt(se);
									se = rigColname;
									se = se.trim();
									int se2 = Integer.parseInt(se);
									if (se1 <= se2) { // ///////*******************2
										// is the defaulted value,
										// need change later
										arraySelect.add(arraytotal[i11]);
										i12++;
									}
								}
							}
							String arrayjoin1[][] = new String[i12][arraySelect
									.get(0).length];// convert the arraylist
													// format
							// into the strring [][] format
							for (int i11 = 0; i11 < i12; i11++) {
								arrayjoin1[i11] = arraySelect.get(i11);
							}

							int i51 = indexpl.indexOf(in);
							int i511 = indexpl.indexOf(in * 10 + 1);
							indi[i51] = 1;

							data.set(i51, arrayjoin1);
							COLNAMES.set(i51, COLNAMES.get(i511));
						}// replace the original information in the data
							// associated
						// with node
						break;
					}

				case JOIN:
					String q4sang = q1.detailString();
					String arrayLEFT[][] = new String[0][0];// data in the left
					// node
					int iLEFT = indexpl.indexOf(in * 10 + 1);
					arrayLEFT = (String[][]) data.get(iLEFT);
					data.set(iLEFT, null);

					String[] cnLEFT = new String[0];// column names LEFT
					cnLEFT = (String[]) COLNAMES.get(iLEFT);

					String arrayRIG[][] = new String[0][0]; // data in the right
					// node
					int iRIG = indexpl.indexOf(in * 10 + 2);
					arrayRIG = (String[][]) data.get(iRIG);
					data.set(iRIG, null);

					String[] cnRIG = new String[0];// column names RIGHT
					cnRIG = (String[]) COLNAMES.get(iRIG);

					ArrayList equaINDEX = new ArrayList();// which two columns
															// should be
					// equal to join
					for (int j1 = 0; j1 < cnRIG.length; j1 = j1 + 2) {
						int flag12 = 0;
						for (int j2 = 0; j2 < cnLEFT.length; j2 = j2 + 2) {
							if (cnRIG[j1 + 1].equals(cnLEFT[j2 + 1])
									&& !cnRIG[j1 + 1].equals("comment")
									&& cnRIG[j1 + 1].contains("key")
									&& cnLEFT[j2 + 1].contains("key")) {
								equaINDEX.add(j2 / 2);
								equaINDEX.add(j1 / 2);
								flag12 = 1;
								// break;
							}
						}
						// if (flag12 == 1) {
						// break;
						// }
					}
					String[] colnames23 = new String[cnLEFT.length
							+ cnRIG.length];
					for (int j2 = 0; j2 < cnLEFT.length; j2++) {
						colnames23[j2] = cnLEFT[j2];
					}
					for (int j2 = 0; j2 < cnRIG.length; j2++) {
						colnames23[j2 + cnLEFT.length] = cnRIG[j2];
					}

					ArrayList<String[]> arrayjoin2 = new ArrayList<String[]>();
					System.gc();
					if ( equaINDEX.size() == 2) {
						String part1_fromleft=cnLEFT[(int)equaINDEX.get(0)*2];
						String part2_fromleft=cnLEFT[(int)equaINDEX.get(0)*2+1];
						java.io.File f1 = new java.io.File(part1_fromleft+"_"+part2_fromleft+".dat");
						
						
						if (q4sang.contains("INDEX") && f1.exists() && (int)equaINDEX.get(0)==0) // have to be the first column which wont be repeating to use the "get" function in ISAM tree structure
						{
							int keyorder = 0;
							File idxFile = new File(
									part1_fromleft+"_"+part2_fromleft+".dat");
							ManagedFile file;
							TestDataStream ds = new TestDataStream(
									keys, values, rows,
									keychaos, true);
							IndexKeySpec keySpec = new GenericIndexKeySpec(
									ds.getSchema(), keys,
									keyorder);// revised
							Datum [] getfromLEFT=null;
							IndexFile idx = null;
							try {
								file = fm.open(idxFile);
								
								
								idx = new ISAMIndex(file, keySpec);
								fm.close(idxFile);
							} catch (IOException e1) {
								// TODO Auto-generated catch block
								e1.printStackTrace();
							}
							
							Datum [] get=new Datum [1];
							for (int j2 = 0; j2 < arrayRIG.length; j2++) {
//								IndexType type = IndexType.ISAM;
//								int keys = 1;// the size of the key
//								int values = 5;// the size of the
//												// value so
//												// keys+values size
//												// is the size of
//												// one row
//								int rows = 100;
//								int frames = 1024;// the size of
//													// neicun
//								int keychaos = 2;// the randomness
//													// of the key
//								int indexSize = 10;// for hash
//								int keyorder = 0;// create
																	// key
																	// by
																	// order
//								BufferManager bm = new BufferManager(
//										frames);
//								FileManager fm = new FileManager(bm);

								
								
								
								try {
								
									get[0]=new Datum.Int(
											Integer.parseInt(arrayRIG[j2][(int) equaINDEX.get(1)]));
									getfromLEFT=idx.get(get);//get the corresponding row by get (index), the second colu is the order in row in original data
								} catch (IOException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
								
								if (getfromLEFT!=null){
								int jc = arrayLEFT[0].length;
								int jn = arrayRIG[0].length;
								String[] arrayLERI = new String[jc + jn];
								for (int j3 = 0; j3 < arrayLEFT[getfromLEFT[1].toInt()].length; j3++) {
										arrayLERI[j3] = arrayLEFT[getfromLEFT[1].toInt()][j3];
								}
								for (int j3 = 0; j3 < arrayRIG[j2].length; j3++) {
									arrayLERI[j3 + arrayLEFT[getfromLEFT[1].toInt()].length] = arrayRIG[j2][j3];
								}
									// arrayLEFT[j1]=null;
									// arrayRIG[j2]=null;
									// System.gc();
								arrayjoin2.add(arrayLERI);
								}
								
//								 System.out.print(j2);
//								 System.out.print("\n");
							}
						}
					
						
						String part1_fromrig=cnRIG[(int)equaINDEX.get(1)*2];
						String part2_fromrig=cnRIG[(int)equaINDEX.get(1)*2+1];
						java.io.File f2 = new java.io.File(part1_fromrig+"_"+part2_fromrig+".dat");
						
						if (q4sang.contains("INDEX") && f2.exists() && (int)equaINDEX.get(1)==0) // have to be the first column which wont be repeating to use the "get" function in ISAM tree structure
						{
							ManagedFile file;
							TestDataStream ds = new TestDataStream(
									keys, values, rows,
									keychaos, true);
							int keyorder = 0;
							IndexKeySpec keySpec = new GenericIndexKeySpec(
									ds.getSchema(), keys,
									keyorder);
							File idxFile = new File(
									part1_fromrig+"_"+part2_fromrig+".dat");
							IndexFile idx = null;
							Datum [] getfromRIG=null;
							try {
								file = fm.open(idxFile);
								idx = new ISAMIndex(file, keySpec);
								fm.close(idxFile);
							} catch (IOException e1) {
								// TODO Auto-generated catch block
								e1.printStackTrace();
							}
							
							Datum [] get=new Datum [1];
							for (int j2 = 0; j2 < arrayLEFT.length; j2++) {
//								IndexType type = IndexType.ISAM;
//								int keys = 1;// the size of the key
//								int values = 5;// the size of the
//												// value so
//												// keys+values size
//												// is the size of
//												// one row
//								int rows = 100;
//								int frames = 1024;// the size of
//													// neicun
//								int keychaos = 2;// the randomness
//													// of the key
//								int indexSize = 10;// for hash
								// create
																	// key
																	// by
																	// order
//								BufferManager bm = new BufferManager(
//										frames);
//								FileManager fm = new FileManager(bm);

								
								// revised
								
								
							
									
									get[0]=new Datum.Int(
											Integer.parseInt(arrayLEFT[j2][(int) equaINDEX.get(0)]));
									try {
										getfromRIG=idx.get(get);
									} catch (IOException e) {
										// TODO Auto-generated catch block
										e.printStackTrace();
									}//get the corresponding row by get (index), the second colu is the order in row in original data
							
								
								if (getfromRIG!=null){
								int jc = arrayLEFT[0].length;
								int jn = arrayRIG[0].length;
								String[] arrayLERI = new String[jc + jn];
								for (int j3 = 0; j3 < arrayLEFT[j2].length; j3++) {
										arrayLERI[j3] = arrayLEFT[j2][j3];
								}
								for (int j3 = 0; j3 < arrayRIG[getfromRIG[1].toInt()].length; j3++) {
									arrayLERI[j3 + arrayLEFT[j2].length] = arrayRIG[getfromRIG[1].toInt()][j3];
								}
									// arrayLEFT[j1]=null;
									// arrayRIG[j2]=null;
									// System.gc();
								arrayjoin2.add(arrayLERI);
								}
								
//								 System.out.print(j2);
//								 System.out.print("\n");
							}
						}
						if ((!q4sang.contains("INDEX" ))|| (!f1.exists() && !f2.exists())) {
							if (part1_fromleft.equals(part2_fromleft.substring(0, 1))){ // the index version will take the right part as known, so search by right
								for (int j1 = 0; j1 < arrayRIG.length; j1++) {
									for (int j2 = 0; j2 < arrayLEFT.length; j2++) {
										if (arrayRIG[j1][(int) equaINDEX.get(1)]
												.equals(arrayLEFT[j2][(int) equaINDEX
														.get(0)])) {
											int jc = arrayLEFT[0].length;
											int jn = arrayRIG[0].length;
											String[] arrayLERI = new String[jc + jn];
											for (int j3 = 0; j3 < arrayLEFT[j2].length; j3++) {
												arrayLERI[j3] = arrayLEFT[j2][j3];
											}
											for (int j3 = 0; j3 < arrayRIG[j1].length; j3++) {
												arrayLERI[j3 + arrayLEFT[j2].length] = arrayRIG[j1][j3];
											}
											// arrayLEFT[j1]=null;
											// arrayRIG[j2]=null;
											// System.gc();
											arrayjoin2.add(arrayLERI);
										}
										// System.out.print(j2);
										// System.out.print("\n");
									}
//									System.out.print(j1);
//									System.out.print("\t");
//									System.out.print(arrayLEFT.length);
//									System.out.print("\n");
								}
							}
							else {	
						for (int j1 = 0; j1 < arrayLEFT.length; j1++) {
							for (int j2 = 0; j2 < arrayRIG.length; j2++) {
								if (arrayLEFT[j1][(int) equaINDEX.get(0)]
										.equals(arrayRIG[j2][(int) equaINDEX
												.get(1)])) {
									int jc = arrayLEFT[0].length;
									int jn = arrayRIG[0].length;
									String[] arrayLERI = new String[jc + jn];
									for (int j3 = 0; j3 < arrayLEFT[j1].length; j3++) {
										arrayLERI[j3] = arrayLEFT[j1][j3];
									}
									for (int j3 = 0; j3 < arrayRIG[j2].length; j3++) {
										arrayLERI[j3 + arrayLEFT[j1].length] = arrayRIG[j2][j3];
									}
									// arrayLEFT[j1]=null;
									// arrayRIG[j2]=null;
									// System.gc();
									arrayjoin2.add(arrayLERI);
								}
								// System.out.print(j2);
								// System.out.print("\n");
							}
//							System.out.print(j1);
//							System.out.print("\t");
//							System.out.print(arrayLEFT.length);
//							System.out.print("\n");
						}
						}
						}
					} else if (equaINDEX.size() == 4) {
						for (int j1 = 0; j1 < arrayLEFT.length; j1++) {
							for (int j2 = 0; j2 < arrayRIG.length; j2++) {
								if (arrayLEFT[j1][(int) equaINDEX.get(0)]
										.equals(arrayRIG[j2][(int) equaINDEX
												.get(1)])
										&& arrayLEFT[j1][(int) equaINDEX.get(2)]
												.equals(arrayRIG[j2][(int) equaINDEX
														.get(3)])) {
									int jc = arrayLEFT[0].length;
									int jn = arrayRIG[0].length;
									String[] arrayLERI = new String[jc + jn];
									for (int j3 = 0; j3 < arrayLEFT[j1].length; j3++) {
										arrayLERI[j3] = arrayLEFT[j1][j3];
									}
									for (int j3 = 0; j3 < arrayRIG[j2].length; j3++) {
										arrayLERI[j3 + arrayLEFT[j1].length] = arrayRIG[j2][j3];
									}
									// arrayLEFT[j1]=null;
									// arrayRIG[j2]=null;
									// System.gc();
									arrayjoin2.add(arrayLERI);
								}
								// System.out.print(j2);
								// System.out.print("\n");
							}
//							System.out.print(j1);
//							System.out.print("\t");
//							System.out.print(arrayLEFT.length);
//							System.out.print("\n");
						}
					}
					String arrayjoin1[][] = new String[arrayjoin2.size()][arrayjoin2
							.get(0).length];
					for (int j4 = 0; j4 < arrayjoin2.size(); j4++) {
						arrayjoin1[j4] = arrayjoin2.get(j4);
						// arrayjoin2.set(j4, null);
						// System.gc();
					}
					// RANGENAMES.set(i5, ragnames23);
					COLNAMES.set(k5 - 1, colnames23);
					data.set(k5 - 1, arrayjoin1); // replace the original
					// information in the data
					// associated with node
					// jointimes++;

					break;
				case NULLSOURCE:
					break;
				case UNION:

					int leftU = indexpl.indexOf(10 * in + 1);
					int rigU = indexpl.indexOf(10 * in + 2);

					int uupnum = 0;
					int udownnum = 0;
					String arrayup[][] = (String[][]) data.get(leftU);
					String arraydown[][] = (String[][]) data.get(rigU);
					uupnum = arrayup[0].length;
					udownnum = arraydown[0].length;

					String arrayunion[][] = new String[arrayup.length
							+ arraydown.length][uupnum];

					for (i = 0; i < arrayup.length; i++) {
						for (j = 0; j < arrayup[i].length; j++)
							arrayunion[i][j] = arrayup[i][j];
					}
					for (i = 0; i < arraydown.length; i++) {
						for (j = 0; j < arraydown[i].length; j++)
							arrayunion[arrayup.length + i][j] = arraydown[i][j];
					}
					int iUnion = indexpl.indexOf(in);
					data.set(iUnion, arrayunion);
					if (in == 1) {
						ArrayList<Datum[]> ret3 = new ArrayList<Datum[]>();
						for (int i7 = 0; i7 < arrayunion.length; i7++) {
							Datum[] ret113 = new Datum[arrayunion[0].length];// now
							// the
							// datum
							// []
							// lenth
							// is
							// the
							// number
							// of
							// calculations
							for (int i13 = 0; i13 < arrayunion[0].length; i13++) {
								ret113[i13] = new Datum.Int(
										Integer.parseInt(arrayunion[i7][i13]));
							}
							ret3.add(ret113);// each row is a datum [] type
							// ret3.add(new Datum[] {new
							// Datum.Int(Integer.parseInt(arrayunion[i7][0]))});
						}
						List<Var> qv1 = q.getSchemaVars();
						TableBuilder output1 = new TableBuilder();
						for (int icao = 0; icao < qv1.size(); icao++) {
							output1.newCell(qv1.get(icao).toString());
						}
						output1.addDividerLine();
						List<Datum[]> computedResults11 = ret3;
						int queryID1 = 0;
						for (; queryID1 < computedResults11.size(); queryID1++) {
							Datum[] row = computedResults11.get(queryID1);
							output1.newRow();
							for (Datum d : row) {
								output1.newCell(d.toString());
							}
						}
						return ret3;
					}
					break;

				}
				// }

				// }

			}
		} else {
			// project 3 //"sort merge push down" doesnot inculde "index"

			// ////////////////////////////Five Important Matrix search [1] [2]
			// [3]
			// [4] ////
			ArrayList<PlanNode> pl = new ArrayList<PlanNode>(); // the arraylist
																// records the
																// nodes
																// of the tree
																// [1]
			ArrayList indexpl = new ArrayList(); // the arraylist records the
													// structure of the tree [2]
			int root = 1;
			int i = 0;
			int j = 0;
			int j0 = 1;
			int in = 0;// index in the tree
			pl.add(q);
			indexpl.add(root);// recording the tree relationship
			PlanNode q1;
			PlanNode q3;
			PlanNode ql;
			PlanNode qr;

			while (j0 > j)// no new nodes are found
			{
				int num = 0;
				int jold = j;
				for (int k = j + 1; k <= j0; k++) {
					q1 = pl.get(k - 1);
					in = (Integer) indexpl.get(k - 1);
					int m = 1;
					switch (q1.type) {
					case AGGREGATE:
						j = pl.size();
						AggregateNode q2 = (AggregateNode) q1;
						q3 = q2.getChild();
						pl.add(q3);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case PROJECT:
						j = pl.size();
						ProjectionNode q21 = (ProjectionNode) q1;
						q3 = q21.getChild();
						pl.add(q3);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case SELECT:
						j = pl.size();
						SelectionNode q22 = (SelectionNode) q1;
						q3 = q22.getChild();
						pl.add(q3);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case JOIN:
						j = pl.size();
						JoinNode q23 = (JoinNode) q1;
						ql = q23.getLHS();
						qr = q23.getRHS();
						pl.add(ql);
						indexpl.add(in * 10 + m);
						m = m + 1;
						pl.add(qr);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case UNION:
						j = pl.size();
						UnionNode q25 = (UnionNode) q1;
						ql = q25.getLHS();
						qr = q25.getRHS();
						pl.add(ql);
						indexpl.add(in * 10 + m);
						m = m + 1;
						pl.add(qr);
						indexpl.add(in * 10 + m);
						m = m + 1;
						break;
					case NULLSOURCE:
						j = pl.size();
						indexpl.add(in * 10 + m);
						m = m + 1;
						// i=1;
						break;
					case SCAN:
						// j=pl.size();
						// indexpl.add(in*10+m);
						num = num + 1;
						break;
					}
				}
				if (num == j0 - jold) {
					break;
				}
				j0 = pl.size();
			}
			int s = pl.size();
			int jointimes = 0;
			int indi[] = new int[s];// if the child node has provided some
									// useful
									// information
			ArrayList data = new ArrayList();// the third arraylist, which
												// records
												// the data associated with node
												// [3]
			ArrayList COLNAMES = new ArrayList();// record the column names of
													// the
													// arraylist in "data" (the
													// former row) [4]
			ArrayList RANGENAMES = new ArrayList();// record the range names of
													// the
													// arraylist in "data" [5]
			for (int k1 = 0; k1 < s; k1++) {
				ArrayList<String[]> data1 = new ArrayList();
				data.add(data1);
				COLNAMES.add(data1);
				RANGENAMES.add(data1);
			}
			ArrayList table = new ArrayList();// from bottom to the top,
												// previously
												// from top to the bottom
			for (int k5 = s; k5 >= 1; k5--) {
				// if (indi[k]==0){
				in = (Integer) indexpl.get(k5 - 1);
				// if (indexpl.contains(in-1))// this is one of the binary child
				// nodes
				// {}
				// else //this is a unary child node or its father node is unary
				// {
				q1 = pl.get(k5 - 1);

				switch (q1.type) {
				case SCAN:
					String q1s = q1.detailString();
					if (q1s.contains(";"))// push down
					{
						String[] q1s_pushdown = q1s.split(";");
						byte[] B1 = q1s_pushdown[1].getBytes();
						int b = q1s_pushdown[1].indexOf("(");
						int c1 = q1s_pushdown[1].indexOf(")");

						ArrayList col11 = new ArrayList();

						ArrayList index = new ArrayList();
						for (int in1 = 0; in1 < B1.length; in1++) {
							if (B1[in1] == ',') {
								index.add(in1);
							}
						}
						int a = q1s_pushdown[1].indexOf("[");
						String rangeVar = q1s_pushdown[1].substring(a + 1, b);
						table.add(in);
						table.add(rangeVar);

						// range names
						String[] raname = rangeVar.toLowerCase().split("");
						String[] raname1 = new String[1];
						raname1[0] = raname[1];

						int c22 = (int) index.get(0);
						String col1 = q1s_pushdown[1].substring(b + 1, c22);
						table.add(col1);
						col11.add(raname[1]);
						col11.add(col1);
						for (int in1 = 1; in1 < index.size(); in1++) {
							col1 = q1s_pushdown[1].substring(
									(int) index.get(in1 - 1) + 2,
									(int) index.get(in1));
							table.add(col1);
							col11.add(raname[1]);
							col11.add(col1);
						}
						col1 = q1s_pushdown[1].substring(
								(int) index.get(index.size() - 1) + 2, c1);
						table.add(col1);
						col11.add(raname[1]);
						col11.add(col1);

						// column names
						String[] colname = new String[col11.size()];
						for (int i111 = 0; i111 < col11.size(); i111++) {
							colname[i111] = (String) col11.get(i111);
						}

						Schema.TableFromFile table_R123 = tables.get(rangeVar);
						String pathadd123 = table_R123.getFile().toString();
						Readtable readr123 = new Readtable();// edu.buffalo.cse.sql.io
						String arraytotal12[][] = readr123.readfile("test/"
								+ pathadd123);

						// consider the select condition in SCAN
						ArrayList left = new ArrayList();
						ArrayList right = new ArrayList();
						ArrayList tord = new ArrayList(); // from table or the
															// real
															// data 1 or 0
						ArrayList calcu = new ArrayList(); // record the
															// 1:"=";2,"<";3,">";4:">=";5"<="
															// if
															// (q1s_pushdown[0].contains("<=")){
						// String [] q4s2 = q1s_pushdown[0].split("<=");
						// int ins = 0;
						// for (int u = 0; u < colname.length; u = u + 2) {
						// if (q4s2[0].contains(colname[u])
						// && q4s2[0].contains(colname[u + 1])) {
						// ins = u / 2;
						// }
						// }
						// left.add(ins);
						//
						// ins = 0;
						// for (int u = 0; u < colname.length; u = u + 2) {
						// if (q4s2[1].contains(colname[u])
						// && q4s2[1].contains(colname[u + 1])) {
						// ins = u / 2;
						// }
						// }
						// if (ins != 0) {
						// right.add(ins);
						// tord.add(1);
						// } else if (ins == 0) {
						// String sdot = q4s2[1].substring(
						// q4s2[1].indexOf("<=") + 2,
						// q4s2[1].length()-1);
						// if (sdot.contains("+")) {
						// int s6 = sdot.indexOf("+");
						// int sle = Integer.parseInt(sdot.substring(
						// 0, s6));
						// int sri = Integer.parseInt(sdot.substring(
						// s6 + 1, sdot.length()));
						//
						// sdot = Integer.toString(sle + sri);
						// }
						// right.add(sdot);
						// tord.add(0);
						// }
						// calcu.add(5);
						// }
						String q4s = q1s_pushdown[0];
						q4s = q4s.replace(" ", "");
						q4s = q4s.replace("SCAN", "");
						q4s = q4s.replace("[", "");
						q4s = q4s.replace("]", "");
						q4s = q4s.replace("(", "");
						q4s = q4s.replace(")", "");
						ArrayList q4s1 = new ArrayList();
						String[] q4s20 = q4s.split("AND");
						for (int s1 = 0; s1 < q4s20.length; s1++) {
							String[] q4s3 = q4s20[s1].split("OR");
							for (int s2 = 0; s2 < q4s3.length; s2++) {
								q4s1.add(q4s3[s2]);
							}
						}
						// transfer the arraylist into string []
						String[] q4s3 = new String[q4s1.size()];
						for (int s3 = 0; s3 < q4s3.length; s3++) {
							q4s3[s3] = (String) q4s1.get(s3);
						}

						// String [] q4s3=new String [1];
						// q4s3[0]=q1s_pushdown[0];
						String[] q4s2;
						for (int s1 = 0; s1 < q4s3.length; s1++) {
							if (q4s3[s1].contains("=")
									&& !q4s3[s1].contains(">")
									&& !q4s3[s1].contains("<")) {
								q4s2 = q4s3[s1].split("=");
								int ins = 0;
								for (int u = 0; u < colname.length; u = u + 2) {
									if (q4s2[0].contains(colname[u])
											&& q4s2[0].contains(colname[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < colname.length; u = u + 2) {
									if (q4s2[1].contains(colname[u])
											&& q4s2[1].contains(colname[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									int idot = q4s2[1].indexOf("'");
									String sdot = q4s2[1].substring(idot + 1,
											q4s2[1].length() - 1);
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(1);
							} else if (q4s3[s1].contains("<")
									&& !q4s3[s1].contains("<=")) {
								q4s2 = q4s3[s1].split("<");
								int ins = 0;
								for (int u = 0; u < colname.length; u = u + 2) {
									if (q4s2[0].contains(colname[u])
											&& q4s2[0].contains(colname[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < colname.length; u = u + 2) {
									if (q4s2[1].contains(colname[u])
											&& q4s2[1].contains(colname[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf("<") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(2);
							} else if (q4s3[s1].contains("<=")) {
								q4s2 = q4s3[s1].split("<=");
								int ins = 0;
								for (int u = 0; u < colname.length; u = u + 2) {
									if (q4s2[0].contains(colname[u])
											&& q4s2[0].contains(colname[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < colname.length; u = u + 2) {
									if (q4s2[1].contains(colname[u])
											&& q4s2[1].contains(colname[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf("<=") + 1,
											q4s2[1].length());
									if (sdot.contains("+")) {
										int s6 = sdot.indexOf("+");
										int sle = Integer.parseInt(sdot
												.substring(0, s6));
										int sri = Integer.parseInt(sdot
												.substring(s6 + 1,
														sdot.length()));

										sdot = Integer.toString(sle + sri);
									}
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(5);
							} else if (q4s3[s1].contains(">")
									&& !q4s3[s1].contains(">=")) {
								q4s2 = q4s3[s1].split(">");
								int ins = 0;
								for (int u = 0; u < colname.length; u = u + 2) {
									if (q4s2[0].contains(colname[u])
											&& q4s2[0].contains(colname[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < colname.length; u = u + 2) {
									if (q4s2[1].contains(colname[u])
											&& q4s2[1].contains(colname[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf(">") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(3);
							} else if (q4s3[s1].contains(">=")) {
								q4s2 = q4s3[s1].split(">=");
								int ins = 0;
								for (int u = 0; u < colname.length; u = u + 2) {
									if (q4s2[0].contains(colname[u])
											&& q4s2[0].contains(colname[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < colname.length; u = u + 2) {
									if (q4s2[1].contains(colname[u])
											&& q4s2[1].contains(colname[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf(">=") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(4);
							}
						}
						ArrayList<String[]> finalresults = new ArrayList<String[]>();
						ArrayList<String[]> test1 = new ArrayList<String[]>();
						for (int se3 = 0; se3 < arraytotal12.length; se3++) {
							test1.add(arraytotal12[se3]);
						}
						// String [][] test1=arraySELECT;
						for (int se2 = 0; se2 < calcu.size(); se2++) {
							if ((int) calcu.get(se2) == 1) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										if (test2[(int) left.get(se2)]
												.equals((String) right.get(se2))) {
											finalresults.add(test2);
										}
									}
								} else if ((int) tord.get(se2) == 1) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										if (test2[(int) left.get(se2)]
												.equals(test2[(int) right
														.get(se2)])) {
											finalresults.add(test2);
										}
									}
								}
							} else if ((int) calcu.get(se2) == 2) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										String test3 = test2[(int) left
												.get(se2)];
										test3 = test3.replace("-", "");
										if (!test3.contains(".")) {
											int test4 = Integer.parseInt(test3);
											int test5 = Integer
													.parseInt((String) right
															.get(se2));
											if (test4 < test5) {
												finalresults.add(test2);
											}
										} else if (test3.contains(".")) {
											float test4 = Float
													.parseFloat(test3);
											float test5 = Float
													.parseFloat((String) right
															.get(se2));
											if (test4 < test5) {
												finalresults.add(test2);
											}
										}

									}
								}
							} else if ((int) calcu.get(se2) == 3) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										String test3 = test2[(int) left
												.get(se2)];
										test3 = test3.replace("-", "");
										if (!test3.contains(".")) {
											int test4 = Integer.parseInt(test3);
											int test5 = Integer
													.parseInt((String) right
															.get(se2));
											if (test4 > test5) {
												finalresults.add(test2);
											}
										} else if (test3.contains(".")) {
											float test4 = Float
													.parseFloat(test3);
											float test5 = Float
													.parseFloat((String) right
															.get(se2));
											if (test4 > test5) {
												finalresults.add(test2);
											}
										}

									}
								}
							} else if ((int) calcu.get(se2) == 4) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										String test3 = test2[(int) left
												.get(se2)];
										test3 = test3.replace("-", "");

										if (!test3.contains(".")) {
											int test4 = Integer.parseInt(test3);
											int test5 = Integer
													.parseInt((String) right
															.get(se2));
											if (test4 > test5 || test4 == test5) {
												finalresults.add(test2);
											}
										} else if (test3.contains(".")) {
											float test4 = Float
													.parseFloat(test3);
											float test5 = Float
													.parseFloat((String) right
															.get(se2));
											if (test4 > test5 || test4 == test5) {
												finalresults.add(test2);
											}
										}
									}
								}
							} else if ((int) calcu.get(se2) == 5) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										String test3 = test2[(int) left
												.get(se2)];
										test3 = test3.replace("-", "");

										if (!test3.contains(".")) {
											int test4 = Integer.parseInt(test3);
											int test5 = Integer
													.parseInt((String) right
															.get(se2));
											if (test4 < test5 || test4 == test5) {
												finalresults.add(test2);
											}
										} else if (test3.contains(".")) {
											float test4 = Float
													.parseFloat(test3);
											float test5 = Float
													.parseFloat((String) right
															.get(se2));
											if (test4 < test5 || test4 == test5) {
												finalresults.add(test2);
											}
										}
									}
								}
							}

							test1 = finalresults;
							finalresults = new ArrayList<String[]>();
						}
						String arrayjoin1[][] = new String[test1.size()][test1
								.get(0).length];// convert the arraylist format
												// into
												// the strring [][] format
						
//						File tofile = new File("Q6_noindex_results.txt");
//						FileWriter fw = null;
//						try {
//							fw = new FileWriter(tofile, true);
//						} catch (IOException e1) {
//							// TODO Auto-generated catch block
//							e1.printStackTrace();
//						}				
//												
						for (int i11 = 0; i11 < test1.size(); i11++) {
							arrayjoin1[i11] = test1.get(i11);
//							try {
//								
//								
////								fw.write(Integer.toString(1));
////								fw.write(",");
////								fw.write(Integer.toString(2));
////								fw.write("\r\n");
//								for (int o4=0;o4<8;o4++){
//								fw.write(arrayjoin1[i11][o4]);
//								fw.write("\t");
//								}
//								fw.write(arrayjoin1[i11][10]);
//								fw.write("\r\n");
//								
//							} catch (IOException e) {
//								// TODO Auto-generated catch block
//								e.printStackTrace();
//							}
						}
//						try {
//							fw.close();
//						} catch (IOException e) {
//							// TODO Auto-generated catch block
//							e.printStackTrace();
//						}
						
						
						
//						for (int o2 = 0; o2 < arrayjoin1.length ; o2++) {
//							for (int o3 = 0; o3 < arrayjoin1.length - 1; o3++) {
//								String [] ss;
//								arrayjoin1[o3][10]=arrayjoin1[o3][10].replace("-", "");
//								arrayjoin1[o3+1][10]=arrayjoin1[o3+1][10].replace("-", "");
//								if (Integer.parseInt(arrayjoin1[o3][10])>Integer.parseInt(arrayjoin1[o3 + 1][10])) {
//									ss=null;
//									ss = arrayjoin1[o3];
//									arrayjoin1[o3] = arrayjoin1[o3 + 1];
//									arrayjoin1[o3 + 1] = ss;
//									
//								}
//							}
//							System.out.println(o2);
//						}
//						File tofile = new File("Q6_noindex_results.txt");
//						FileWriter fw;
//						try {
//							fw = new FileWriter(tofile, true);
//							
////							fw.write(Integer.toString(1));
////							fw.write(",");
////							fw.write(Integer.toString(2));
////							fw.write("\r\n");
//							for (int o5=1;o5<arrayjoin1.length;o5++){
//							for (int o4=0;o4<8;o4++){
//								fw.write(arrayjoin1[o5][o4]);
//								fw.write("\t");
//								}
//								fw.write(arrayjoin1[o5][10]);
//								fw.write("\r\n");}
//						} catch (IOException e) {
//							// TODO Auto-generated catch block
//							e.printStackTrace();
//						}
						
						
						int i341 = indexpl.indexOf(in);// this child node can
														// provide
														// data to its father
														// node
						indi[i341] = 1;
						data.set(i341, arrayjoin1);// the data gotten by
													// scanning
						COLNAMES.set(i341, colname);
						// RANGENAMES.set(i341,raname1);
						break;
					} else {
						byte[] B1 = q1s.getBytes();
						int b = q1s.indexOf("(");
						int c1 = q1s.indexOf(")");

						ArrayList col11 = new ArrayList();

						ArrayList index = new ArrayList();
						for (int in1 = 0; in1 < B1.length; in1++) {
							if (B1[in1] == ',') {
								index.add(in1);
							}
						}
						int a = q1s.indexOf("[");
						String rangeVar = q1s.substring(a + 1, b);
						table.add(in);
						table.add(rangeVar);

						// range names
						String[] raname = rangeVar.toLowerCase().split("");
						String[] raname1 = new String[1];
						raname1[0] = raname[1];

						int c22 = (int) index.get(0);
						String col1 = q1s.substring(b + 1, c22);
						table.add(col1);
						col11.add(raname[1]);
						col11.add(col1);
						for (int in1 = 1; in1 < index.size(); in1++) {
							col1 = q1s.substring((int) index.get(in1 - 1) + 2,
									(int) index.get(in1));
							table.add(col1);
							col11.add(raname[1]);
							col11.add(col1);
						}
						col1 = q1s.substring(
								(int) index.get(index.size() - 1) + 2, c1);
						table.add(col1);
						col11.add(raname[1]);
						col11.add(col1);

						// column names
						String[] colname = new String[col11.size()];
						for (int i111 = 0; i111 < col11.size(); i111++) {
							colname[i111] = (String) col11.get(i111);
						}

						Schema.TableFromFile table_R123 = tables.get(rangeVar);
						String pathadd123 = table_R123.getFile().toString();
						Readtable readr123 = new Readtable();// edu.buffalo.cse.sql.io
						String arraytotal12[][] = new String[1][1];
						if (pathadd123.contains("test")) {
							arraytotal12 = readr123.readfile(pathadd123);
						}

						else if (!pathadd123.contains("test")) {
							arraytotal12 = readr123.readfile("test/"
									+ pathadd123);
						}

						int i341 = indexpl.indexOf(in);// this child node can
														// provide
														// data to its father
														// node
						indi[i341] = 1;
						data.set(i341, arraytotal12);// the data gotten by
														// scanning
						COLNAMES.set(i341, colname);
						// RANGENAMES.set(i341,raname1);
						break;
					}
				case AGGREGATE:
					String q2s = q1.detailString();

					q2s = q2s.replace(" ", "");
					String[] q31s = q2s.split(":");
					ArrayList q41s = new ArrayList();// all the queries it needs
					for (int i4s = 0; i4s < q31s.length; i4s++) {
						if (q31s[i4s].contains(",")) {
							String[] q5s = q31s[i4s].split(",");
							q41s.add(q5s[0]);
						} else if (q31s[i4s].contains("]")) {
							String[] q5s = q31s[i4s].split("]");
							q41s.add(q5s[0]);
						}

					}

					int i1 = 0;
					int i2 = 0;
					int index1 = -100;
					ArrayList<Datum[]> ret = new ArrayList<Datum[]>();

					int cal = 0; // calculation number in AGGREGATE
					String arraytotal[][] = new String[0][0];
					int i66 = indexpl.indexOf(in * 10 + 1);
					arraytotal = (String[][]) data.get(i66);

					String[] colnames2 = new String[0];
					colnames2 = (String[]) COLNAMES.get(i66);

					// find the "group by" key colnames
					ArrayList groupBY = new ArrayList();
					for (int u = 0; u < q41s.size(); u++) {
						String s1 = (String) q41s.get(u);
						if (!s1.contains("SUM") && !s1.contains("AVG")
								&& !s1.contains("COUNT")) {
							groupBY.add(s1);
						}
					}
					// no groupBY columns
					if (groupBY.isEmpty()) {

						int[] flag = new int[arraytotal.length];
						String[] s1Groupby = new String[q41s.size()];
						ArrayList<String[]> resultGroupby = new ArrayList<String[]>(); // the
																						// final
																						// result
						int length = arraytotal.length;
						for (int u3 = 0; u3 < q41s.size(); u3++) {
							String s1 = (String) q41s.get(u3);
							if (s1.contains("SUM")) {
								int a1 = s1.indexOf("M");
								int b1 = s1.length() - 1;
								i1 = 0;
								i2 = 0;
								index1 = -100;
								String parString = s1.substring(a1 + 2, b1);
								if (parString.contains("*")) {
									BigDecimal sum = new BigDecimal (0);
									for (int y2 = 0; y2 < arraytotal.length; y2++) {
										String[] splitStr = parString
												.split("[*]");
										float[] floatResult = new float[splitStr.length];
										for (int y1 = 0; y1 < splitStr.length; y1++) {
											if (splitStr[y1].contains("-")) {
												splitStr[y1] = splitStr[y1]
														.replace("(", "");
												splitStr[y1] = splitStr[y1]
														.replace(")", "");
												String[] splitStr1 = splitStr[y1]
														.split("[-]");
												float forward = 0;
												float bacward = 0;

												int index_for = 0;
												for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
													if (splitStr1[0]
															.contains(colnames2[u5])
															&& splitStr1[0]
																	.contains(colnames2[u5 + 1])) {
														index_for = u5 / 2;
													}
												}
												if (index_for == 0) {
													String s11 = splitStr1[0];
													float f1 = Float
															.parseFloat(splitStr1[0]);
													forward = Float
															.parseFloat(splitStr1[0]);
												}
												int index_bac = 0;
												for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
													if (splitStr1[1]
															.contains(colnames2[u5])
															&& splitStr1[1]
																	.contains(colnames2[u5 + 1])) {
														index_bac = u5 / 2;
													}
												}
												if (index_bac != 0) {
													bacward = Float
															.parseFloat(arraytotal[y2][index_bac]);
												}
												floatResult[y1] = forward
														- bacward;
											} else if (splitStr[y1]
													.contains("+")) {
												splitStr[y1] = splitStr[y1]
														.replace("(", "");
												splitStr[y1] = splitStr[y1]
														.replace(")", "");
												String[] splitStr1 = splitStr[y1]
														.split("[+]");
												float forward = 0;
												float bacward = 0;

												int index_for = 0;
												for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
													if (splitStr1[0]
															.contains(colnames2[u5])
															&& splitStr1[0]
																	.contains(colnames2[u5 + 1])) {
														index_for = u5 / 2;
													}
												}
												if (index_for == 0) {
													forward = Float
															.parseFloat(splitStr1[0]);
												}
												int index_bac = 0;
												for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
													if (splitStr1[1]
															.contains(colnames2[u5])
															&& splitStr1[1]
																	.contains(colnames2[u5 + 1])) {
														index_bac = u5 / 2;
													}
												}
												if (index_bac != 0) {
													bacward = Float
															.parseFloat(arraytotal[y2][index_bac]);
												}
												floatResult[y1] = forward
														+ bacward;
											} else {
												int index_1 = 0;
												for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
													if (splitStr[y1]
															.contains(colnames2[u5])
															&& splitStr[y1]
																	.contains(colnames2[u5 + 1])) {
														index_1 = u5 / 2;
													}
												}
												floatResult[y1] = Float
														.parseFloat(arraytotal[y2][index_1]);
											}
										}
										BigDecimal sum1 = new BigDecimal(1);
										for (int y3 = 0; y3 < floatResult.length; y3++) {
											float sum3 = sum1.floatValue() * floatResult[y3];
											sum1=new BigDecimal((String.valueOf(sum3)));
										}
										float sum2 = sum.floatValue() + sum1.floatValue();
										sum=new BigDecimal(String.valueOf(sum2));
									}
									s1Groupby[u3] = sum.toString();

								}
							}
							resultGroupby.add(s1Groupby);
						}
						for (int y3 = 0; y3 < resultGroupby.size(); y3++) {
							Datum[] ret13 = new Datum[q41s.size()];
							String[] s11 = resultGroupby.get(y3);
							for (int y4 = 0; y4 < ret13.length; y4++) {
								ret13[y4] = new Datum.Str(s11[y4]);
							}
							ret.add(ret13);
						}

					} else {
						// find the index of the "group by" colnames in the data
						// of
						// next
						// node
						ArrayList groupIndex = new ArrayList();
						for (int u1 = 0; u1 < groupBY.size(); u1++) {
							String s1 = (String) groupBY.get(u1);
							String[] s11 = s1.split("[.]");
							for (int u = 0; u < colnames2.length; u = u + 2) {
								if (s11[0].equals((String) colnames2[u])
										&& s11[1]
												.equals((String) colnames2[u + 1])) {
									groupIndex.add(u / 2);
								}
							}
						}

						int[] flag = new int[arraytotal.length];
						ArrayList<String[]> resultGroupby = new ArrayList<String[]>(); // the
																						// final
																						// result

						for (int u = 0; u < arraytotal.length; u++) {
							ArrayList<String[]> arrayGroupby = new ArrayList<String[]>();
							int lengthGroupby = 0;
							if (flag[u] == 0) {// group the data
								arrayGroupby.add(arraytotal[u]);
								lengthGroupby++;
								for (int u1 = u + 1; u1 < arraytotal.length; u1++) {
									int FLAG = 0;
									for (int u2 = 0; u2 < groupIndex.size(); u2++) {// group
																					// index
																					// must
																					// be
																					// the
																					// same
										String s1 = arraytotal[u1][(int) groupIndex
												.get(u2)];
										String s2 = arraytotal[u][(int) groupIndex
												.get(u2)];
										if (!s1.equals(s2)) {
											FLAG = 1;
										}
									}
									if (FLAG == 0) {
										arrayGroupby.add(arraytotal[u1]);
										lengthGroupby++;
										flag[u1] = 1; // has been checked
									}
								}
								flag[u] = 1;
								// the arrayGroupby is known, then we can
								// calculate
								// the
								// corresponding results

								String[][] stringGroupby = new String[lengthGroupby][arrayGroupby
										.get(0).length];
								for (int u4 = 0; u4 < lengthGroupby; u4++) {
									stringGroupby[u4] = arrayGroupby.get(u4);
								}
								String[] s1Groupby = new String[q41s.size()];// to
																				// save
																				// the
																				// calculation
																				// result
																				// for
																				// each
																				// group
								int y = 0;
								for (int u3 = 0; u3 < q41s.size(); u3++) {
									String s1 = (String) q41s.get(u3);
									if (!s1.contains("SUM")
											&& !s1.contains("AVG")
											&& !s1.contains("COUNT")) {
										s1Groupby[u3] = stringGroupby[0][(int) groupIndex
												.get(y)];// save the group by
															// key
										y = y + 1;
									} else if (s1.contains("SUM")) {
										int a1 = s1.indexOf("M");
										int b1 = s1.length() - 1;
										i1 = 0;
										i2 = 0;
										index1 = -100;
										String parString = s1.substring(a1 + 2,
												b1);
										if (parString.contains("*")) {
											float sum = 0;
											for (int y2 = 0; y2 < stringGroupby.length; y2++) {
												String[] splitStr = parString
														.split("[*]");
												float[] floatResult = new float[splitStr.length];
												for (int y1 = 0; y1 < splitStr.length; y1++) {
													if (splitStr[y1]
															.contains("-")) {
														splitStr[y1] = splitStr[y1]
																.replace("(",
																		"");
														splitStr[y1] = splitStr[y1]
																.replace(")",
																		"");
														String[] splitStr1 = splitStr[y1]
																.split("[-]");
														float forward = 0;
														float bacward = 0;

														int index_for = 0;
														for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
															if (splitStr1[0]
																	.contains(colnames2[u5])
																	&& splitStr1[0]
																			.contains(colnames2[u5 + 1])) {
																index_for = u5 / 2;
															}
														}
														if (index_for == 0) {
															String s11 = splitStr1[0];
															float f1 = Float
																	.parseFloat(splitStr1[0]);
															forward = Float
																	.parseFloat(splitStr1[0]);
														}
														int index_bac = 0;
														for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
															if (splitStr1[1]
																	.contains(colnames2[u5])
																	&& splitStr1[1]
																			.contains(colnames2[u5 + 1])) {
																index_bac = u5 / 2;
															}
														}
														if (index_bac != 0) {
															bacward = Float
																	.parseFloat(stringGroupby[y2][index_bac]);
														}
														floatResult[y1] = forward
																- bacward;
													} else if (splitStr[y1]
															.contains("+")) {
														splitStr[y1] = splitStr[y1]
																.replace("(",
																		"");
														splitStr[y1] = splitStr[y1]
																.replace(")",
																		"");
														String[] splitStr1 = splitStr[y1]
																.split("[+]");
														float forward = 0;
														float bacward = 0;

														int index_for = 0;
														for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
															if (splitStr1[0]
																	.contains(colnames2[u5])
																	&& splitStr1[0]
																			.contains(colnames2[u5 + 1])) {
																index_for = u5 / 2;
															}
														}
														if (index_for == 0) {
															forward = Float
																	.parseFloat(splitStr1[0]);
														}
														int index_bac = 0;
														for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
															if (splitStr1[1]
																	.contains(colnames2[u5])
																	&& splitStr1[1]
																			.contains(colnames2[u5 + 1])) {
																index_bac = u5 / 2;
															}
														}
														if (index_bac != 0) {
															bacward = Float
																	.parseFloat(stringGroupby[y2][index_bac]);
														}
														floatResult[y1] = forward
																+ bacward;
													} else {
														int index_1 = 0;
														for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
															if (splitStr[y1]
																	.contains(colnames2[u5])
																	&& splitStr[y1]
																			.contains(colnames2[u5 + 1])) {
																index_1 = u5 / 2;
															}
														}
														floatResult[y1] = Float
																.parseFloat(stringGroupby[y2][index_1]);
													}
												}
												float sum1 = 1;
												for (int y3 = 0; y3 < floatResult.length; y3++) {
													sum1 = sum1
															* floatResult[y3];
												}
												sum = sum + sum1;
											}
											s1Groupby[u3] = Float.toString(sum);

										} else {
											// find the index of the "group by"
											// colnames
											// in the data of next node
											ArrayList groupIndex1 = new ArrayList();
											for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
												if (s1.contains(colnames2[u5])
														&& s1.contains(colnames2[u5 + 1])) {
													groupIndex1.add(u5 / 2);
												}
											}
											int sum = 0;
											float sumf = 0;
											for (int u7 = 0; u7 < stringGroupby.length; u7++) {
												String str1 = stringGroupby[u7][(int) groupIndex1
														.get(0)];
												if (str1.contains(".")) {
													float sum1 = Float
															.parseFloat(str1);
													sumf = sumf + sum1;
												} else if (!str1.contains(".")) {
													int sum1 = Integer
															.parseInt(str1);
													sum = sum + sum1;
												}

											}
											if (sum == 0) {
												s1Groupby[u3] = Float
														.toString(sumf);
											} else if (sum != 0) {
												s1Groupby[u3] = Integer
														.toString(sum);
											}

										}
									} else if (s1.contains("AVG")) {
										int a1 = s1.indexOf("G(");
										int b1 = 0;
										for (int i41 = a1 + 1; i41 < s1
												.length(); i41++) {
											if (s1.substring(i41, i41 + 1)
													.equals(")")) {
												b1 = i41;
												break;
											}
										}
										i1 = 0;
										i2 = 0;
										index1 = -100;
										String parString = s1.substring(a1 + 2,
												b1);

										ArrayList groupIndex1 = new ArrayList();
										for (int u5 = 0; u5 < colnames2.length; u5 = u5 + 2) {
											if (s1.contains(colnames2[u5])
													&& s1.contains(colnames2[u5 + 1])) {
												groupIndex1.add(u5 / 2);
											}
										}
										int sum = 0;
										float sumf = 0;
										for (int u7 = 0; u7 < stringGroupby.length; u7++) {
											String str1 = stringGroupby[u7][(int) groupIndex1
													.get(0)];
											if (str1.contains(".")) {
												float sum1 = Float
														.parseFloat(str1);
												sumf = sumf + sum1;
											} else if (!str1.contains(".")) {
												int sum1 = Integer
														.parseInt(str1);
												sum = sum + sum1;
											}

										}

										if (sum == 0) {
											s1Groupby[u3] = Float.toString(sumf
													/ stringGroupby.length);
										} else if (sum != 0) {
											float sum2 = sum
													/ stringGroupby.length;
											s1Groupby[u3] = Float
													.toString(sum2);
										}

									} else if (s1.contains("COUNT")) {
										s1Groupby[u3] = Integer
												.toString(lengthGroupby);
									}
								}
								resultGroupby.add(s1Groupby);
							}

						}
						for (int y3 = 0; y3 < resultGroupby.size(); y3++) {
							Datum[] ret13 = new Datum[q41s.size()];
							String[] s11 = resultGroupby.get(y3);
							for (int y4 = 0; y4 < ret13.length; y4++) {
								ret13[y4] = new Datum.Str(s11[y4]);
							}
							ret.add(ret13);
						}
					}
					List<Var> qv = q.getSchemaVars();
					TableBuilder output = new TableBuilder();
					output.newRow();
					for (int icao = 0; icao < qv.size(); icao++) {
						output.newCell(qv.get(icao).toString());
					}
					// System.out.println(output);
					output.addDividerLine();
					List<Datum[]> computedResults1 = ret;
					int queryID = 0;
					for (; queryID < computedResults1.size(); queryID++) {
						Datum[] row = computedResults1.get(queryID);
						output.newRow();
						for (Datum d : row) {
							output.newCell(d.toString());
						}
					}
					System.out.println(output);
					return ret;
					// break;
				case PROJECT:

					break;
				case SELECT:

					// int [] colIndex=new int [table.size()];
					String q4s = q1.detailString();
					// System.out.println(q4s);
					q4s = q4s.trim();
					char[] c = q4s.toCharArray();

					String arraySELECT[][] = new String[0][0];
					int iSELECT = indexpl.indexOf(in * 10 + 1);
					arraySELECT = (String[][]) data.get(iSELECT);

					String[] cnSELECT = new String[0];
					cnSELECT = (String[]) COLNAMES.get(iSELECT);
					if (q4s.contains("AND") && q4s.contains("OR")) {
						// seperate q4s by "AND" "OR"
						q4s = q4s.replace(" ", "");
						q4s = q4s.replace("SELECT", "");
						q4s = q4s.replace("[", "");
						q4s = q4s.replace("]", "");
						q4s = q4s.replace("(", "");
						q4s = q4s.replace(")", "");
						ArrayList q4s1 = new ArrayList();
						String[] q4s2 = q4s.split("AND");
						for (int s1 = 0; s1 < q4s2.length; s1++) {
							String[] q4s3 = q4s2[s1].split("OR");
							for (int s2 = 0; s2 < q4s3.length; s2++) {
								q4s1.add(q4s3[s2]);
							}
						}
						// transfer the arraylist into string []
						String[] q4s3 = new String[q4s1.size()];
						for (int s3 = 0; s3 < q4s3.length; s3++) {
							q4s3[s3] = (String) q4s1.get(s3);
						}

						// find the relationships between the left and right in
						// the
						// conditions
						ArrayList left = new ArrayList();
						ArrayList right = new ArrayList();
						ArrayList tord = new ArrayList(); // from table or the
															// real
															// data 1 or 0
						ArrayList calcu = new ArrayList(); // record the
															// 1:"=";2,"<";3,">";4:">=";5"<="
						for (int s1 = 0; s1 < q4s3.length; s1++) {
							if (q4s3[s1].contains("=")
									&& !q4s3[s1].contains(">")
									&& !q4s3[s1].contains("<")) {
								q4s2 = q4s3[s1].split("=");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									int idot = q4s2[1].indexOf("'");
									String sdot = q4s2[1].substring(idot + 1,
											q4s2[1].length() - 1);
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(1);
							} else if (q4s3[s1].contains("<")
									&& !q4s3[s1].contains("<=")) {
								q4s2 = q4s3[s1].split("<");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf("<") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(2);
							} else if (q4s3[s1].contains("<=")) {
								q4s2 = q4s3[s1].split("<=");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf("<=") + 1,
											q4s2[1].length());
									if (sdot.contains("+")) {
										int s6 = sdot.indexOf("+");
										int sle = Integer.parseInt(sdot
												.substring(0, s6));
										int sri = Integer.parseInt(sdot
												.substring(s6 + 1,
														sdot.length()));

										sdot = Integer.toString(sle + sri);
									}
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(5);
							} else if (q4s3[s1].contains(">")
									&& !q4s3[s1].contains(">=")) {
								q4s2 = q4s3[s1].split(">");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf(">") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(3);
							} else if (q4s3[s1].contains(">=")) {
								q4s2 = q4s3[s1].split(">=");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf(">=") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(4);
							}
						}
						ArrayList<String[]> FINAL = new ArrayList<String[]>();// this
																				// records
																				// the
																				// final
																				// results
						// decide if it includs very long "OR"
						ArrayList indexOR = new ArrayList();

						for (int s5 = 0; s5 < left.size(); s5++) {
							if (left.get(s5) == left.get(0) && s5 > 1) {
								indexOR.add(s5);
							}
						}
						if (indexOR.size() == 1) {
						}// only one whole search query
						else if (indexOR.size() > 1) {// several queries because
														// of
														// "OR"
							ArrayList<String[]> finalresults = new ArrayList<String[]>();
							ArrayList<String[]> test1 = new ArrayList<String[]>();
							for (int se3 = 0; se3 < arraySELECT.length; se3++) {
								test1.add(arraySELECT[se3]);
							}
							// String [][] test1=arraySELECT;
							int se2 = 0;
							while (se2 < calcu.size()) {

								if (indexOR.contains(se2)) {// restart because
															// of
															// "OR"
									for (int se3 = 0; se3 < test1.size(); se3++) {
										FINAL.add(test1.get(se3));
									}
									finalresults = new ArrayList<String[]>();
									test1 = new ArrayList<String[]>();
									for (int se3 = 0; se3 < arraySELECT.length; se3++) {
										test1.add(arraySELECT[se3]);
									}
								}

								int gap = 1;
								int gap0 = se2 + 1;
								while (gap0 < left.size()
										&& left.get(gap0) == left.get(se2)
										&& calcu.get(gap0) == calcu.get(se2)) {
									gap++;
									gap0++;
								}
								// several connecutive "OR"
								if (gap > 1) {
									int se8 = 0;
									while (se8 < gap) {
										if ((int) calcu.get(se2 + se8) == 1) {
											if ((int) tord.get(se2 + se8) == 0) {
												for (int se1 = 0; se1 < test1
														.size(); se1++) {
													String[] test2 = test1
															.get(se1);
													String test3 = test2[(int) left
															.get(se2 + se8)];
													test3 = test3.replace(" ",
															"");
													if (test3
															.equals((String) right
																	.get(se2
																			+ se8))) {
														finalresults.add(test2);
													}
												}
											} else if ((int) tord
													.get(se2 + se8) == 1) {
												for (int se1 = 0; se1 < test1
														.size(); se1++) {
													String[] test2 = test1
															.get(se1);
													if (test2[(int) left
															.get(se2 + se8)]
															.equals(test2[(int) right
																	.get(se2
																			+ se8)])) {
														finalresults.add(test2);
													}
												}
											}
										}
										se8++;
									}

								} else {
									if ((int) calcu.get(se2) == 1) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace(" ", "");
												if (test3.equals((String) right
														.get(se2))) {
													finalresults.add(test2);
												}
											}
										} else if ((int) tord.get(se2) == 1) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												if (test2[(int) left.get(se2)]
														.equals(test2[(int) right
																.get(se2)])) {
													finalresults.add(test2);
												}
											}
										}
									} else if ((int) calcu.get(se2) == 2) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");
												if (!test3.contains(".")) {
													int test4 = Integer
															.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 < test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 < test5) {
														finalresults.add(test2);
													}
												}

											}
										}
									} else if ((int) calcu.get(se2) == 3) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");
												if (!test3.contains(".")) {
													int test4 = Integer
															.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 > test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 > test5) {
														finalresults.add(test2);
													}
												}

											}
										}
									} else if ((int) calcu.get(se2) == 4) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");

												if (!test3.contains(".")) {
													int test4 = Integer
															.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 > test5
															|| test4 == test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 > test5
															|| test4 == test5) {
														finalresults.add(test2);
													}
												}
											}
										}
									} else if ((int) calcu.get(se2) == 5) {
										if ((int) tord.get(se2) == 0) {
											for (int se1 = 0; se1 < test1
													.size(); se1++) {
												String[] test2 = test1.get(se1);
												String test3 = test2[(int) left
														.get(se2)];
												test3 = test3.replace("-", "");

												if (!test3.contains(".")) {
													int test4 = Integer
															.parseInt(test3);
													int test5 = Integer
															.parseInt((String) right
																	.get(se2));
													if (test4 < test5
															|| test4 == test5) {
														finalresults.add(test2);
													}
												} else if (test3.contains(".")) {
													float test4 = Float
															.parseFloat(test3);
													float test5 = Float
															.parseFloat((String) right
																	.get(se2));
													if (test4 < test5
															|| test4 == test5) {
														finalresults.add(test2);
													}
												}
											}
										}
									}

								}
								se2 = se2 + gap;
								test1 = finalresults;
								finalresults = new ArrayList<String[]>();
							}
							String arrayjoin1[][] = new String[FINAL.size()][FINAL
									.get(0).length];// convert the arraylist
													// format
													// into
													// the strring [][] format
							for (int i11 = 0; i11 < FINAL.size(); i11++) {
								arrayjoin1[i11] = FINAL.get(i11);
							}

							int i51 = indexpl.indexOf(in);
							int i511 = indexpl.indexOf(in * 10 + 1);
							indi[i51] = 1;
							data.set(i51, arrayjoin1);
							COLNAMES.set(i51, COLNAMES.get(i511));
							break;
						}

					} else if (q4s.contains("AND") && !q4s.contains("OR")) {
						q4s = q4s.replace(" ", "");
						q4s = q4s.replace("SELECT", "");
						q4s = q4s.replace("[", "");
						q4s = q4s.replace("]", "");
						q4s = q4s.replace("(", "");
						q4s = q4s.replace(")", "");
						String[] q4s1 = q4s.split("AND");
						ArrayList left = new ArrayList();
						ArrayList right = new ArrayList();
						ArrayList tord = new ArrayList(); // from table or the
															// real
															// data 1 or 0
						ArrayList calcu = new ArrayList(); // record the
															// 1:"=";2,"<";3,">";4:">="
						for (int s1 = 0; s1 < q4s1.length; s1++) {
							if (q4s1[s1].contains("=")
									&& !q4s1[s1].contains(">")
									&& !q4s1[s1].contains("<")) {
								String[] q4s2 = q4s1[s1].split("=");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									int idot = q4s2[1].indexOf("'");
									String sdot = q4s2[1].substring(idot + 1,
											q4s2[1].length() - 1);
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(1);
							} else if (q4s1[s1].contains("<")) {
								String[] q4s2 = q4s1[s1].split("<");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf("<") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(2);
							} else if (q4s1[s1].contains(">")
									&& !q4s1[s1].contains(">=")) {
								String[] q4s2 = q4s1[s1].split(">");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf(">") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(3);
							} else if (q4s1[s1].contains(">=")) {
								String[] q4s2 = q4s1[s1].split(">=");
								int ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[0].contains(cnSELECT[u])
											&& q4s2[0]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								left.add(ins);

								ins = 0;
								for (int u = 0; u < cnSELECT.length; u = u + 2) {
									if (q4s2[1].contains(cnSELECT[u])
											&& q4s2[1]
													.contains(cnSELECT[u + 1])) {
										ins = u / 2;
									}
								}
								if (ins != 0) {
									right.add(ins);
									tord.add(1);
								} else if (ins == 0) {
									String sdot = q4s2[1].substring(
											q4s2[1].indexOf(">=") + 1,
											q4s2[1].length());
									right.add(sdot);
									tord.add(0);
								}
								calcu.add(4);
							}
						}
						// after the conditions are all detected
						ArrayList<String[]> finalresults = new ArrayList<String[]>();
						ArrayList<String[]> test1 = new ArrayList<String[]>();
						for (int se3 = 0; se3 < arraySELECT.length; se3++) {
							test1.add(arraySELECT[se3]);
						}
						// String [][] test1=arraySELECT;
						for (int se2 = 0; se2 < calcu.size(); se2++) {
							if ((int) calcu.get(se2) == 1) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										if (test2[(int) left.get(se2)]
												.equals((String) right.get(se2))) {
											finalresults.add(test2);
										}
									}
								} else if ((int) tord.get(se2) == 1) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										if (test2[(int) left.get(se2)]
												.equals(test2[(int) right
														.get(se2)])) {
											finalresults.add(test2);
										}
									}
								}
							} else if ((int) calcu.get(se2) == 2) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										String test3 = test2[(int) left
												.get(se2)];
										test3 = test3.replace("-", "");
										if (!test3.contains(".")) {
											int test4 = Integer.parseInt(test3);
											int test5 = Integer
													.parseInt((String) right
															.get(se2));
											if (test4 < test5) {
												finalresults.add(test2);
											}
										} else if (test3.contains(".")) {
											float test4 = Float
													.parseFloat(test3);
											float test5 = Float
													.parseFloat((String) right
															.get(se2));
											if (test4 < test5) {
												finalresults.add(test2);
											}
										}

									}
								}
							} else if ((int) calcu.get(se2) == 3) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										String test3 = test2[(int) left
												.get(se2)];
										test3 = test3.replace("-", "");
										if (!test3.contains(".")) {
											int test4 = Integer.parseInt(test3);
											int test5 = Integer
													.parseInt((String) right
															.get(se2));
											if (test4 > test5) {
												finalresults.add(test2);
											}
										} else if (test3.contains(".")) {
											float test4 = Float
													.parseFloat(test3);
											float test5 = Float
													.parseFloat((String) right
															.get(se2));
											if (test4 > test5) {
												finalresults.add(test2);
											}
										}

									}
								}
							} else if ((int) calcu.get(se2) == 4) {
								if ((int) tord.get(se2) == 0) {
									for (int se1 = 0; se1 < test1.size(); se1++) {
										String[] test2 = test1.get(se1);
										String test3 = test2[(int) left
												.get(se2)];
										test3 = test3.replace("-", "");

										if (!test3.contains(".")) {
											int test4 = Integer.parseInt(test3);
											int test5 = Integer
													.parseInt((String) right
															.get(se2));
											if (test4 > test5 || test4 == test5) {
												finalresults.add(test2);
											}
										} else if (test3.contains(".")) {
											float test4 = Float
													.parseFloat(test3);
											float test5 = Float
													.parseFloat((String) right
															.get(se2));
											if (test4 > test5 || test4 == test5) {
												finalresults.add(test2);
											}
										}
									}
								}
							}
							test1 = finalresults;
							finalresults = new ArrayList<String[]>();
						}
						String arrayjoin1[][] = new String[test1.size()][test1
								.get(0).length];// convert the arraylist format
												// into
												// the strring [][] format
						for (int i11 = 0; i11 < test1.size(); i11++) {
							arrayjoin1[i11] = test1.get(i11);
						}

						int i51 = indexpl.indexOf(in);
						int i511 = indexpl.indexOf(in * 10 + 1);
						indi[i51] = 1;
						data.set(i51, arrayjoin1);
						COLNAMES.set(i51, COLNAMES.get(i511));
						break;

					} else {// 04/12/2013
						ArrayList<String> colnames1 = new ArrayList();
						ArrayList<String> ragnames1 = new ArrayList();
						int icol1 = 0;
						// System.out.println(sp[0]);
						// ArrayList dot=new ArrayList ();
						int leftdot = 0;
						int rightdot = 0;
						for (int i11 = 0; i11 < c.length; i11++) { // got the
																	// index
																	// of '.'
							if (c[i11] == '.') {
								if (leftdot == 0) {
									leftdot = i11;
								} else if (rightdot == 0) {
									rightdot = i11;
								}
							}
						}

						String leftRgename = String.valueOf(c[leftdot - 1]);
						String leftColname = String.valueOf(c[leftdot + 1]);
						String rigRgename = "";
						String rigColname = "";
						if (rightdot != 0) {
							rigRgename = String.valueOf(c[rightdot - 1]);
							rigColname = String.valueOf(c[rightdot + 1]);
						} else if (rightdot == 0) {
							if (q4s.contains("<=")) {
								leftColname = q4s.substring(leftdot + 1,
										q4s.indexOf("<=") - 1);
								rigColname = q4s
										.substring(q4s.indexOf("<=") + 2,
												q4s.indexOf(")"));
							}
						}

						int l = 0;
						int r = 0;
						if (leftdot != 0 && rightdot == 0) {
							i2 = table.indexOf(leftColname);
							int i6 = indexpl.indexOf(in * 10 + 1);
							arraytotal = (String[][]) data.get(i6);
							ArrayList<String[]> arraySelect = new ArrayList<String[]>();
							int i12 = 0;
							if (q4s.contains("<=")) {
								for (int i11 = 0; i11 < arraytotal.length; i11++) {
									String s1 = arraytotal[i11][i2 - 2]
											.replace("-", "");
									String se = s1;
									int se1 = Integer.parseInt(se);
									se = rigColname;
									se = se.trim();
									int se2 = Integer.parseInt(se);
									if (se1 <= se2) { // ///////*******************2
														// is the defaulted
														// value,
														// need change later
										arraySelect.add(arraytotal[i11]);
										i12++;
									}
								}
							}
							String arrayjoin1[][] = new String[i12][arraySelect
									.get(0).length];// convert the arraylist
													// format
													// into the strring [][]
													// format
							for (int i11 = 0; i11 < i12; i11++) {
								arrayjoin1[i11] = arraySelect.get(i11);
							}

							int i51 = indexpl.indexOf(in);
							int i511 = indexpl.indexOf(in * 10 + 1);
							indi[i51] = 1;

							data.set(i51, arrayjoin1);
							COLNAMES.set(i51, COLNAMES.get(i511));
						}// replace the original information in the data
							// associated
							// with node
						break;
					}

				case JOIN:

					String arrayLEFT[][] = new String[0][0];// data in the left
															// node
					int iLEFT = indexpl.indexOf(in * 10 + 1);
					arrayLEFT = (String[][]) data.get(iLEFT);
					data.set(iLEFT, null);

					String[] cnLEFT = new String[0];// column names LEFT
					cnLEFT = (String[]) COLNAMES.get(iLEFT);

					String arrayRIG[][] = new String[0][0]; // data in the right
															// node
					int iRIG = indexpl.indexOf(in * 10 + 2);
					arrayRIG = (String[][]) data.get(iRIG);
					data.set(iRIG, null);

					String[] cnRIG = new String[0];// column names RIGHT
					cnRIG = (String[]) COLNAMES.get(iRIG);

					ArrayList equaINDEX = new ArrayList();// which two columns
															// should be
					// equal to join
					for (int j1 = 0; j1 < cnRIG.length; j1 = j1 + 2) {
						int flag12 = 0;
						for (int j2 = 0; j2 < cnLEFT.length; j2 = j2 + 2) {
							if (cnRIG[j1 + 1].equals(cnLEFT[j2 + 1])
									&& !cnRIG[j1 + 1].equals("comment")
									&& cnRIG[j1 + 1].contains("key")
									&& cnLEFT[j2 + 1].contains("key")) {
								equaINDEX.add(j2 / 2);
								equaINDEX.add(j1 / 2);
								flag12 = 1;
								// break;
							}
						}
						// if (flag12 == 1) {
						// break;
						// }
					}
					String[] colnames23 = new String[cnLEFT.length
							+ cnRIG.length];
					for (int j2 = 0; j2 < cnLEFT.length; j2++) {
						colnames23[j2] = cnLEFT[j2];
					}
					for (int j2 = 0; j2 < cnRIG.length; j2++) {
						colnames23[j2 + cnLEFT.length] = cnRIG[j2];
					}

					ArrayList<String[]> arrayjoin2 = new ArrayList<String[]>();
					System.gc();
					if (equaINDEX.size() == 2) {
						String part1_fromleft=cnLEFT[(int)equaINDEX.get(0)*2];
						String part2_fromleft=cnLEFT[(int)equaINDEX.get(0)*2+1];
						if (part1_fromleft.equals(part2_fromleft.substring(0, 1))){ // the index version will take the right part as known, so search by right
							for (int j1 = 0; j1 < arrayRIG.length; j1++) {
								for (int j2 = 0; j2 < arrayLEFT.length; j2++) {
									if (arrayRIG[j1][(int) equaINDEX.get(1)]
											.equals(arrayLEFT[j2][(int) equaINDEX
													.get(0)])) {
										int jc = arrayLEFT[0].length;
										int jn = arrayRIG[0].length;
										String[] arrayLERI = new String[jc + jn];
										for (int j3 = 0; j3 < arrayLEFT[j2].length; j3++) {
											arrayLERI[j3] = arrayLEFT[j2][j3];
										}
										for (int j3 = 0; j3 < arrayRIG[j1].length; j3++) {
											arrayLERI[j3 + arrayLEFT[j2].length] = arrayRIG[j1][j3];
										}
										// arrayLEFT[j1]=null;
										// arrayRIG[j2]=null;
										// System.gc();
										arrayjoin2.add(arrayLERI);
									}
									// System.out.print(j2);
									// System.out.print("\n");
								}
//								System.out.print(j1);
//								System.out.print("\t");
//								System.out.print(arrayLEFT.length);
//								System.out.print("\n");
							}
						}
						else {
						for (int j1 = 0; j1 < arrayLEFT.length; j1++) {
							for (int j2 = 0; j2 < arrayRIG.length; j2++) {
								if (arrayLEFT[j1][(int) equaINDEX.get(0)]
										.equals(arrayRIG[j2][(int) equaINDEX
												.get(1)])) {
									int jc = arrayLEFT[0].length;
									int jn = arrayRIG[0].length;
									String[] arrayLERI = new String[jc + jn];
									for (int j3 = 0; j3 < arrayLEFT[j1].length; j3++) {
										arrayLERI[j3] = arrayLEFT[j1][j3];
									}
									for (int j3 = 0; j3 < arrayRIG[j2].length; j3++) {
										arrayLERI[j3 + arrayLEFT[j1].length] = arrayRIG[j2][j3];
									}
									// arrayLEFT[j1]=null;
									// arrayRIG[j2]=null;
									// System.gc();
									arrayjoin2.add(arrayLERI);
								}
								// System.out.print(j2);
								// System.out.print("\n");
							}
//							System.out.print(j1);
//							System.out.print("\t");
//							System.out.print(arrayLEFT.length);
//							System.out.print("\n");
						}}
					} else if (equaINDEX.size() == 4) {
						for (int j1 = 0; j1 < arrayLEFT.length; j1++) {
							for (int j2 = 0; j2 < arrayRIG.length; j2++) {
								if (arrayLEFT[j1][(int) equaINDEX.get(0)]
										.equals(arrayRIG[j2][(int) equaINDEX
												.get(1)])
										&& arrayLEFT[j1][(int) equaINDEX.get(2)]
												.equals(arrayRIG[j2][(int) equaINDEX
														.get(3)])) {
									int jc = arrayLEFT[0].length;
									int jn = arrayRIG[0].length;
									String[] arrayLERI = new String[jc + jn];
									for (int j3 = 0; j3 < arrayLEFT[j1].length; j3++) {
										arrayLERI[j3] = arrayLEFT[j1][j3];
									}
									for (int j3 = 0; j3 < arrayRIG[j2].length; j3++) {
										arrayLERI[j3 + arrayLEFT[j1].length] = arrayRIG[j2][j3];
									}
									// arrayLEFT[j1]=null;
									// arrayRIG[j2]=null;
									// System.gc();
									arrayjoin2.add(arrayLERI);
								}
								// System.out.print(j2);
								// System.out.print("\n");
							}
//							System.out.print(j1);
//							System.out.print("\t");
//							System.out.print(arrayLEFT.length);
//							System.out.print("\n");
						}
					}
					String arrayjoin1[][] = new String[arrayjoin2.size()][arrayjoin2
							.get(0).length];
					for (int j4 = 0; j4 < arrayjoin2.size(); j4++) {
						arrayjoin1[j4] = arrayjoin2.get(j4);
						// arrayjoin2.set(j4, null);
						// System.gc();
					}
					// RANGENAMES.set(i5, ragnames23);
					COLNAMES.set(k5 - 1, colnames23);
					data.set(k5 - 1, arrayjoin1); // replace the original
													// information in the data
													// associated with node
					// jointimes++;

					break;
				case NULLSOURCE:
					break;
				case UNION:

					int leftU = indexpl.indexOf(10 * in + 1);
					int rigU = indexpl.indexOf(10 * in + 2);

					int uupnum = 0;
					int udownnum = 0;
					String arrayup[][] = (String[][]) data.get(leftU);
					String arraydown[][] = (String[][]) data.get(rigU);
					uupnum = arrayup[0].length;
					udownnum = arraydown[0].length;

					String arrayunion[][] = new String[arrayup.length
							+ arraydown.length][uupnum];

					for (i = 0; i < arrayup.length; i++) {
						for (j = 0; j < arrayup[i].length; j++)
							arrayunion[i][j] = arrayup[i][j];
					}
					for (i = 0; i < arraydown.length; i++) {
						for (j = 0; j < arraydown[i].length; j++)
							arrayunion[arrayup.length + i][j] = arraydown[i][j];
					}
					int iUnion = indexpl.indexOf(in);
					data.set(iUnion, arrayunion);
					if (in == 1) {
						ArrayList<Datum[]> ret3 = new ArrayList<Datum[]>();
						for (int i7 = 0; i7 < arrayunion.length; i7++) {
							Datum[] ret113 = new Datum[arrayunion[0].length];// now
																				// the
																				// datum
																				// []
																				// lenth
																				// is
																				// the
																				// number
																				// of
																				// calculations
							for (int i13 = 0; i13 < arrayunion[0].length; i13++) {
								ret113[i13] = new Datum.Int(
										Integer.parseInt(arrayunion[i7][i13]));
							}
							ret3.add(ret113);// each row is a datum [] type
							// ret3.add(new Datum[] {new
							// Datum.Int(Integer.parseInt(arrayunion[i7][0]))});
						}
						List<Var> qv1 = q.getSchemaVars();
						TableBuilder output1 = new TableBuilder();
						for (int icao = 0; icao < qv1.size(); icao++) {
							output1.newCell(qv1.get(icao).toString());
						}
						output1.addDividerLine();
						List<Datum[]> computedResults11 = ret3;
						int queryID1 = 0;
						for (; queryID1 < computedResults11.size(); queryID1++) {
							Datum[] row = computedResults11.get(queryID1);
							output1.newRow();
							for (Datum d : row) {
								output1.newCell(d.toString());
							}
						}
						return ret3;
					}
					break;

				}
				// }

				// }

			}
		}

		throw new SqlException("execQuery() is unimplemented");
	}

	public static List<List<Datum[]>> execFile(File program, String flag)
			throws SqlException, IOException {
		try {
			SqlParser parse = new SqlParser(
					new java.io.FileInputStream(program));
			List<Datum[]> ret1 = new ArrayList<Datum[]>();
			List<List<Datum[]>> ret2 = new ArrayList<List<Datum[]>>();
			String s_program = program.toString();
			String[] nametemp = s_program.split("\\.");
			String name = nametemp[0].substring(5);
			
			IndexType type = IndexType.ISAM;
			int keys = 1;// the size of the key
			int values = 5;// the size of the value so
							// keys+values size is the size of
							// one row
			int rows = 100;
			int frames = 1024;// the size of neicun
			int keychaos = 2;// the randomness of the key
			int indexSize = 10;// for hash
			
			BufferManager bm = new BufferManager(frames);
			FileManager fm = new FileManager(bm);
			
			
			try {
				Program p = parse.Program();
				int temp = p.queries.size();
				for (int t360 = 0; t360 < p.queries.size(); t360++) {
					if (flag == "-explain") {
						System.out.println("==========Before===========\n");
						System.out.println(p.queries.get(t360).toString());

						SortMergeJoin sortmergejoin = new SortMergeJoin(true);
						PlanNode node0 = sortmergejoin.rewrite(p.queries
								.get(t360));
						// System.out.println(node0.toString());

						PushDownSelects pushdownselect = new PushDownSelects(
								true);
						PlanNode node1 = pushdownselect.rewrite(node0);

						if (name.equals("TPCH_Q1")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io.File("l_partkey.dat");

							if (f1.exists() ) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								System.out
										.println("==========After===========\n");
								System.out.println(node2.toString());
								
							} else {
								System.out
										.println("==========After===========\n");
								System.out.println(node1.toString());
							}
							
						}
						if (name.equals("TPCH_Q3")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io.File("l_partkey.dat");
							java.io.File f4 = new java.io.File("c_custkey.dat");
							java.io.File f5 = new java.io.File(
									"o_orderdate.dat");

							if (f1.exists() 
									&& f4.exists() && f5.exists()) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								System.out
										.println("==========After===========\n");
								System.out.println(node2.toString());
								
							} else {
								System.out
										.println("==========After===========\n");
								System.out.println(node1.toString());
							}

						}
						if (name.equals("TPCH_Q5")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io.File("l_partkey.dat");
							java.io.File f4 = new java.io.File("c_custkey.dat");
							java.io.File f5 = new java.io.File(
									"o_orderdate.dat");
							java.io.File f6 = new java.io.File("s_suppkey.dat");
							java.io.File f7 = new java.io.File(
									"n_nationkey.dat");
//							java.io.File f8 = new java.io.File(
//									"r_regionkey.dat");

							if (f1.exists() 
									&& f4.exists() && f5.exists()
									&& f6.exists() && f7.exists()
									) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								System.out
										.println("==========After===========\n");
								System.out.println(node2.toString());
							} else {
								System.out
										.println("==========After===========\n");
								System.out.println(node1.toString());
							}
						}
						if (name.equals("TPCH_Q6")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io.File("l_partkey.dat");

							if (f1.exists() ) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								System.out
										.println("==========After===========\n");
								System.out.println(node2.toString());
							} else {
								System.out
										.println("==========After===========\n");
								System.out.println(node1.toString());
							}
						}
						if (name.equals("TPCH_Q10")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io.File("l_partkey.dat");
							java.io.File f4 = new java.io.File("c_custkey.dat");
							java.io.File f5 = new java.io.File(
									"o_orderdate.dat");
							java.io.File f6 = new java.io.File(
									"n_nationkey.dat");

							if (f1.exists() 
									&& f4.exists() && f5.exists()
									&& f6.exists()) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								System.out
										.println("==========After===========\n");
								System.out.println(node2.toString());
							} else {
								System.out
										.println("==========After===========\n");
								System.out.println(node1.toString());
							}
						}

						if (name.equals("TPCH_Q19")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io.File("l_partkey.dat");
							java.io.File f4 = new java.io.File("p_partkey.dat");

							if (f1.exists() 
									&& f4.exists()) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								System.out
										.println("==========After===========\n");
								System.out.println(node2.toString());
							} else {
								System.out
										.println("==========After===========\n");
								System.out.println(node1.toString());
							}
						}
					} else if (flag == "-index") {
						// call index function to generate index
						if (name.equals("TPCH_Q1")) {
							// need to modify
							// ISAMIndex.create("l_shipdate.dat",11);
							// ISAMIndex.create("l_orderkey.dat",1);
							// ISAMIndex.create("l_partkey.dat",2);
							
							
							int keyorder = 10;// create key by order
							String pathfile = "l_shipdate.txt";
							File idxFile = new File("l_shipdate.dat");
							TestDataStream ds = new TestDataStream(keys,
									values, rows, keychaos, true);
							IndexKeySpec keySpec = new GenericIndexKeySpec(
									ds.getSchema(), keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);// only build index for
														// the keyorder column

//							keyorder = 0;
//							pathfile = "l_orderkey.txt";
//							idxFile = new File("l_orderkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);

//							keyorder = 1;
//							pathfile = "l_partkey.txt";
//							idxFile = new File("l_partkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);
							

						}
						if (name.equals("TPCH_Q3")) {
							// need to modify
							// ISAMIndex.create("l_shipdate.dat",11);
							// ISAMIndex.create("l_orderkey.dat",1);
							// ISAMIndex.create("l_partkey.dat",2);
							// ISAMIndex.create("c_custkey.dat",1);
							// ISAMIndex.create("o_orderdate",5);
							//
//							IndexType type = IndexType.ISAM;
//							int keys = 1;// the size of the key
//							int values = 5;// the size of the value so
//											// keys+values size is the size of
//											// one row
//							int rows = 100;
//							int frames = 1024;// the size of neicun
//							int keychaos = 2;// the randomness of the key
//							int indexSize = 10;// for hash
							int keyorder = 10;// create key by order
							String pathfile = "l_shipdate.txt";
							File idxFile = new File("l_shipdate.dat");
//							BufferManager bm = new BufferManager(frames);
//							FileManager fm = new FileManager(bm);
							TestDataStream ds = new TestDataStream(keys,
									values, rows, keychaos, true);
							IndexKeySpec keySpec = new GenericIndexKeySpec(
									ds.getSchema(), keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);// only build index for
							// the keyorder column

//							keyorder = 0;
//							pathfile = "l_orderkey.txt";
//							idxFile = new File("l_orderkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);
							//
//							keyorder = 1;
//							pathfile = "l_partkey.txt";
//							idxFile = new File("l_partkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);

							keyorder = 0;
							pathfile = "c_custkey.txt";
							idxFile = new File("c_custkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
							ds = new TestDataStream(keys, values, rows,
									keychaos, true);
							keySpec = new GenericIndexKeySpec(ds.getSchema(),
									keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);

							keyorder = 4;
							pathfile = "o_orderdate.txt";
							idxFile = new File("o_orderdate.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
							ds = new TestDataStream(keys, values, rows,
									keychaos, true);
							keySpec = new GenericIndexKeySpec(ds.getSchema(),
									keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);
							//
						}
						if (name.equals("TPCH_Q5")) {
							// need to modify
							// ISAMIndex.create("l_shipdate.dat",11);
							// ISAMIndex.create("l_orderkey.dat",1);
							// ISAMIndex.create("l_partkey.dat",2);
							// ISAMIndex.create("c_custkey.dat",1);
							// ISAMIndex.create("o_orderdate",5);
							// ISAMIndex.create("s_suppkey.dat",1);
							// ISAMIndex.create("n_nationkey.dat",1);
							// ISAMIndex.create("r_regionkey.dat",1);
//							IndexType type = IndexType.ISAM;
//							int keys = 1;// the size of the key
//							int values = 5;// the size of the value so
//											// keys+values size is the size of
//											// one row
//							int rows = 100;
//							int frames = 1024;// the size of neicun
//							int keychaos = 2;// the randomness of the key
//							int indexSize = 10;// for hash
							int keyorder = 10;// create key by order
							String pathfile = "l_shipdate.txt";
							File idxFile = new File("l_shipdate.dat");
//							BufferManager bm = new BufferManager(frames);
//							FileManager fm = new FileManager(bm);
							TestDataStream ds = new TestDataStream(keys,
									values, rows, keychaos, true);
							IndexKeySpec keySpec = new GenericIndexKeySpec(
									ds.getSchema(), keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);// only build index for
							// the keyorder column
							
//							keyorder = 0;
//							pathfile = "l_orderkey.txt";
//							idxFile = new File("l_orderkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);
							// //
//							keyorder = 1;
//							pathfile = "l_partkey.txt";
//							idxFile = new File("l_partkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);
							//
							keyorder = 0;
							pathfile = "c_custkey.txt";
							idxFile = new File("c_custkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
							ds = new TestDataStream(keys, values, rows,
									keychaos, true);
							keySpec = new GenericIndexKeySpec(ds.getSchema(),
									keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);
							//
							keyorder = 4;
							pathfile = "o_orderdate.txt";
							idxFile = new File("o_orderdate.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
							ds = new TestDataStream(keys, values, rows,
									keychaos, true);
							keySpec = new GenericIndexKeySpec(ds.getSchema(),
									keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);

							keyorder = 0;
							pathfile = "s_suppkey.txt";
							idxFile = new File("s_suppkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
							ds = new TestDataStream(keys, values, rows,
									keychaos, true);
							keySpec = new GenericIndexKeySpec(ds.getSchema(),
									keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);

							keyorder = 0;
							pathfile = "n_nationkey.txt";
							idxFile = new File("n_nationkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
							ds = new TestDataStream(keys, values, rows,
									keychaos, true);
							keySpec = new GenericIndexKeySpec(ds.getSchema(),
									keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);

//							keyorder = 0;
//							pathfile = "r_regionkey.txt";
//							idxFile = new File("r_regionkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);

						}
						if (name.equals("TPCH_Q6")) {
							// need to modify
							// ISAMIndex.create("l_shipdate.dat",11);
							// ISAMIndex.create("l_orderkey.dat",1);
							// ISAMIndex.create("l_partkey.dat",2);
//							IndexType type = IndexType.ISAM;
//							int keys = 1;// the size of the key
//							int values = 5;// the size of the value so
//											// keys+values size is the size of
//											// one row
//							int rows = 100;
//							int frames = 1024;// the size of neicun
//							int keychaos = 2;// the randomness of the key
//							int indexSize = 10;// for hash
							int keyorder = 10;// create key by order
							String pathfile = "l_shipdate.txt";
							File idxFile = new File("l_shipdate.dat");
//							BufferManager bm = new BufferManager(frames);
//							FileManager fm = new FileManager(bm);
							TestDataStream ds = new TestDataStream(keys,
									values, rows, keychaos, true);
							IndexKeySpec keySpec = new GenericIndexKeySpec(
									ds.getSchema(), keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);// only build index for
							// the keyorder column

//							keyorder = 0;
//							pathfile = "l_orderkey.txt";
//							idxFile = new File("l_orderkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);
							// //
//							keyorder = 1;
//							pathfile = "l_partkey.txt";
//							idxFile = new File("l_partkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);
						}
						if (name.equals("TPCH_Q10")) {
							// need to modify
							// ISAMIndex.create("l_shipdate.dat",11);
							// ISAMIndex.create("l_orderkey.dat",1);
							// ISAMIndex.create("l_partkey.dat",2);
							// ISAMIndex.create("c_custkey.dat",1);
							// ISAMIndex.create("o_orderdate",5);
							// ISAMIndex.create("n_nationkey.dat",1);
//							IndexType type = IndexType.ISAM;
//							int keys = 1;// the size of the key
//							int values = 5;// the size of the value so
//											// keys+values size is the size of
//											// one row
//							int rows = 100;
//							int frames = 1024;// the size of neicun
//							int keychaos = 2;// the randomness of the key
//							int indexSize = 10;// for hash
							int keyorder = 10;// create key by order
							String pathfile = "l_shipdate.txt";
							File idxFile = new File("l_shipdate.dat");
//							BufferManager bm = new BufferManager(frames);
//							FileManager fm = new FileManager(bm);
							TestDataStream ds = new TestDataStream(keys,
									values, rows, keychaos, true);
							IndexKeySpec keySpec = new GenericIndexKeySpec(
									ds.getSchema(), keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);// only build index for
							// the keyorder column
			

//							keyorder = 0;
//							pathfile = "l_orderkey.txt";
//							idxFile = new File("l_orderkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);
							// //
//							keyorder = 1;
//							pathfile = "l_partkey.txt";
//							idxFile = new File("l_partkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);
							//
							keyorder = 0;
							pathfile = "c_custkey.txt";
							idxFile = new File("c_custkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
							ds = new TestDataStream(keys, values, rows,
									keychaos, true);
							keySpec = new GenericIndexKeySpec(ds.getSchema(),
									keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);
							//
							keyorder = 4;
							pathfile = "o_orderdate.txt";
							idxFile = new File("o_orderdate.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
							ds = new TestDataStream(keys, values, rows,
									keychaos, true);
							keySpec = new GenericIndexKeySpec(ds.getSchema(),
									keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);

							keyorder = 0;
							pathfile = "n_nationkey.txt";
							idxFile = new File("n_nationkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
							ds = new TestDataStream(keys, values, rows,
									keychaos, true);
							keySpec = new GenericIndexKeySpec(ds.getSchema(),
									keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);

						}

						if (name.equals("TPCH_Q19")) {
							// need to modify
							// ISAMIndex.create("l_shipdate.dat",11);
							// ISAMIndex.create("l_orderkey.dat",1);
							// ISAMIndex.create("l_partkey.dat",2);
							// ISAMIndex.create("p_partkey.dat",1);
//							IndexType type = IndexType.ISAM;
//							int keys = 1;// the size of the key
//							int values = 5;// the size of the value so
//											// keys+values size is the size of
//											// one row
//							int rows = 100;
//							int frames = 1024;// the size of neicun
//							int keychaos = 2;// the randomness of the key
//							int indexSize = 10;// for hash
							int keyorder = 10;// create key by order
							String pathfile = "l_shipdate.txt";
							File idxFile = new File("l_shipdate.dat");
//							BufferManager bm = new BufferManager(frames);
//							FileManager fm = new FileManager(bm);
							TestDataStream ds = new TestDataStream(keys,
									values, rows, keychaos, true);
							IndexKeySpec keySpec = new GenericIndexKeySpec(
									ds.getSchema(), keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);// only build index for
							// the keyorder column

//							keyorder = 0;
//							pathfile = "l_orderkey.txt";
//							idxFile = new File("l_orderkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);
							// //
//							keyorder = 1;
//							pathfile = "l_partkey.txt";
//							idxFile = new File("l_partkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
//							ds = new TestDataStream(keys, values, rows,
//									keychaos, true);
//							keySpec = new GenericIndexKeySpec(ds.getSchema(),
//									keys, keyorder);// revised
//							ISAMIndex.create(fm, idxFile, ds, keySpec,
//									pathfile, keyorder);

							keyorder = 0;
							pathfile = "p_partkey.txt";
							idxFile = new File("p_partkey.dat");
//							bm = new BufferManager(frames);
//							fm = new FileManager(bm);
							ds = new TestDataStream(keys, values, rows,
									keychaos, true);
							keySpec = new GenericIndexKeySpec(ds.getSchema(),
									keys, keyorder);// revised
							ISAMIndex.create(fm, idxFile, ds, keySpec,
									pathfile, keyorder);
						}

					} else {

						SortMergeJoin sortmergejoin = new SortMergeJoin(true);
						PlanNode node0 = sortmergejoin.rewrite(p.queries
								.get(t360));

						PushDownSelects pushdownselect = new PushDownSelects(
								true);
						PlanNode node1 = pushdownselect.rewrite(node0);

						if (name.equals("TPCH_Q1")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io..ile("l_partkey.dat");

							if (f1.exists() ) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								ret1 = execQuery(p.tables, node2, 2);
								ret2.add(ret1);
								f1.delete();
							} else {
//								System.out.println("no index");
								ret1 = execQuery(p.tables, node1, 1);
								ret2.add(ret1);
							
							}
						} else if (name.equals("TPCH_Q3")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io.File("l_partkey.dat");
							java.io.File f4 = new java.io.File("c_custkey.dat");
							java.io.File f5 = new java.io.File(
									"o_orderdate.dat");

							if (f1.exists() 
									&& f4.exists() && f5.exists()) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								ret1 = execQuery(p.tables, node2, 2);
								ret2.add(ret1);
								f1.deleteOnExit();
								f4.deleteOnExit();
								f5.deleteOnExit();
							} else {
//								System.out.println("no index");
								ret1 = execQuery(p.tables, node1, 1);
								ret2.add(ret1);
							}
						} else if (name.equals("TPCH_Q5")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io.File("l_partkey.dat");
							java.io.File f4 = new java.io.File("c_custkey.dat");
							java.io.File f5 = new java.io.File(
									"o_orderdate.dat");
							java.io.File f6 = new java.io.File("s_suppkey.dat");
							java.io.File f7 = new java.io.File(
									"n_nationkey.dat");
//							java.io.File f8 = new java.io.File(
//									"r_regionkey.dat");

							if (f1.exists() 
									&& f4.exists() && f5.exists()
									&& f6.exists() && f7.exists()
									) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								ret1 = execQuery(p.tables, node2, 2);
								ret2.add(ret1);
								f1.deleteOnExit();
								f4.deleteOnExit();
								f5.deleteOnExit();
								f6.deleteOnExit();
								f7.deleteOnExit();
							} else {
//								System.out.println("no index");
								ret1 = execQuery(p.tables, node1, 1);
								ret2.add(ret1);
							}
						} else if (name.equals("TPCH_Q6")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io.File("l_partkey.dat");

							if (f1.exists() ) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								ret1 = execQuery(p.tables, node2, 2);
								ret2.add(ret1);
								f1.deleteOnExit();
							} else {
//								System.out.println("no index");
								ret1 = execQuery(p.tables, node1, 1);
								ret2.add(ret1);
							}
						} else if (name.equals("TPCH_Q10")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io.File("l_partkey.dat");
							java.io.File f4 = new java.io.File("c_custkey.dat");
							java.io.File f5 = new java.io.File(
									"o_orderdate.dat");
							java.io.File f6 = new java.io.File(
									"n_nationkey.dat");

							if (f1.exists() 
									&& f4.exists() && f5.exists()
									&& f6.exists()) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								ret1 = execQuery(p.tables, node2, 2);
								ret2.add(ret1);
								f1.deleteOnExit();
								f4.deleteOnExit();
								f5.deleteOnExit();
								f6.deleteOnExit();
							} else {
//								System.out.println("no index");
								ret1 = execQuery(p.tables, node1, 1);
								ret2.add(ret1);
							}
						}

						else if (name.equals("TPCH_Q19")) {
							java.io.File f1 = new java.io.File("l_shipdate.dat");
//							java.io.File f2 = new java.io.File("l_orderkey.dat");
//							java.io.File f3 = new java.io.File("l_partkey.dat");
							java.io.File f4 = new java.io.File("p_partkey.dat");

							if (f1.exists() 
									&& f4.exists()) {
								IndexScanJoin indexscanjoin = new IndexScanJoin(
										true);
								PlanNode node2 = indexscanjoin.rewrite(node1);
								ret1 = execQuery(p.tables, node2, 2);
								ret2.add(ret1);
								f1.deleteOnExit();
								f4.deleteOnExit(); 
							} else {
//								System.out.println("no index");
								ret1 = execQuery(p.tables, node1, 1);
								ret2.add(ret1);
							}
						} else {
							ret1 = execQuery(p.tables, node1, 1);
							ret2.add(ret1);
						}

					}
				}
				return ret2;
			} catch (ParseException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		throw new SqlException("execQuery() is unimplemented");
	}
}